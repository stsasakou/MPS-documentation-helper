<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><link rel="canonical" href="https://www.jetbrains.com/help/mps/typesystem.html" data-react-helmet="true"/><meta charset="UTF-8"></meta><meta name="built-on" content="2024-08-08T15:14:21.812681719"><meta name="build-number" content="170"><title>Typesystem | MPS Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"definingatypesystemforyourlanguage","level":0,"title":"Defining A Typesystem For Your Language","anchor":"#definingatypesystemforyourlanguage"},{"id":"whatisatypesystem?","level":0,"title":"What is a typesystem?","anchor":"#whatisatypesystem?"},{"id":"types","level":0,"title":"Types","anchor":"#types"},{"id":"inferencerules","level":0,"title":"Inference Rules","anchor":"#inferencerules"},{"id":"equationsandinequations","level":0,"title":"Equations And Inequations","anchor":"#equationsandinequations"},{"id":"weakandstrongsubtyping","level":0,"title":"Weak And Strong Subtyping","anchor":"#weakandstrongsubtyping"},{"id":"subtypingrules","level":0,"title":"Subtyping Rules","anchor":"#subtypingrules"},{"id":"comparisoninequationsandcomparisonrules","level":0,"title":"Comparison Inequations And Comparison Rules","anchor":"#comparisoninequationsandcomparisonrules"},{"id":"quotations","level":0,"title":"Quotations","anchor":"#quotations"},{"id":"antiquotations","level":0,"title":"Antiquotations","anchor":"#antiquotations"},{"id":"examplesofinferencerules","level":0,"title":"Examples Of Inference Rules","anchor":"#examplesofinferencerules"},{"id":"typevariables","level":0,"title":"Type Variables","anchor":"#typevariables"},{"id":"meetandjointypes","level":0,"title":"Meet and Join types","anchor":"#meetandjointypes"},{"id":"\"whenconcrete\"blocks","level":0,"title":"\"When Concrete\" Blocks","anchor":"#\"whenconcrete\"blocks"},{"id":"overloadedoperators","level":0,"title":"Overloaded Operators","anchor":"#overloadedoperators"},{"id":"replacementrules","level":0,"title":"Replacement Rules","anchor":"#replacementrules"},{"id":"type-system,trace","level":0,"title":"Type-system, trace","anchor":"#type-system,trace"},{"id":"advancedfeaturesoftypesystemlanguage","level":0,"title":"Advanced features of typesystem language","anchor":"#advancedfeaturesoftypesystemlanguage"},{"id":"overridingtypeofliteralorexpression","level":0,"title":"Overriding type of literal or expression","anchor":"#overridingtypeofliteralorexpression"},{"id":"checkingrules","level":0,"title":"Checking rules","anchor":"#checkingrules"},{"id":"typesystemadditionalmethods","level":0,"title":"Additional methods","anchor":"#typesystemadditionalmethods"}]</script><script type="application/json" id="topic-shortcuts">{"ShowIntentionActions":{"Windows":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"PC"},"Emacs":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"PC"},"GNOME":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"PC"},"KDE":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"PC"},"Sublime Text":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"PC"},"XWin":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"PC"},"macOS":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"MAC"},"Sublime Text (macOS)":{"keystrokes":[{"keys":["mod-Alt","key-Enter"]}],"platform":"MAC"}}}</script><link href="https://resources.jetbrains.com/storage/help-app/v6/app.css" rel="stylesheet"><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="Typesystem | MPS"><meta property="og:description" content=""><meta property="og:image" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><meta property="og:site_name" content="MPS Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://www.jetbrains.com/help/mps/typesystem.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@jetbrains_MPS"><meta name="twitter:title" content="Typesystem | MPS"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@jetbrains_MPS"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://www.jetbrains.com/help/mps/typesystem.html#webpage",
    "url": "https://www.jetbrains.com/help/mps/typesystem.html",
    "name": "Typesystem | MPS",
    "description": "",
    "image": "https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://www.jetbrains.com/help/mps/#website",
    "url": "https://www.jetbrains.com/help/mps/",
    "name": "MPS Help"
}</script><!-- End Schema.org --><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
</head><body data-id="typesystem" data-main-title="Typesystem" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="mps-user-s-guide.topic|MPS User's Guide///language-definition.topic|Language-definition"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MPS 2024.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="typesystem" id="typesystem.topic">Typesystem</h1><section class="chapter"><h2 id="definingatypesystemforyourlanguage" data-toc="definingatypesystemforyourlanguage">Defining A Typesystem For Your Language</h2><p id="-o3vd0q_2">This page describes the MPS type-system to a great detail. If you would prefer a more lightweight introduction into defining your first type-system rules, consider checking out the <a href="cookbook-type-system.html" id="-o3vd0q_3">Type-system cookbook</a>.</p><p id="-o3vd0q_4">If you would like to get familiar with the ways you can use the type-system from your code, you may also look at the <a href="using-typesystem.html" id="-o3vd0q_5">Using the type-system</a> chapter.</p></section><section class="chapter"><h2 id="whatisatypesystem?" data-toc="whatisatypesystem?">What is a typesystem?</h2><p id="-o3vd0q_6">A typesystem is a part of a language definition assigning types to the nodes in the models written using the language. The typesystem language is also used to check certain constraints on nodes and their types. Information about types of nodes is useful for:</p><ul class="list _bullet" id="-o3vd0q_7"><li class="list__item" id="-o3vd0q_8"><p>finding type errors</p></li><li class="list__item" id="-o3vd0q_9"><p>checking conditions on nodes' types during generation to apply only appropriate generator rules</p></li><li class="list__item" id="-o3vd0q_10"><p>providing information required for certain refactorings (for example, for the "extract variable" refactoring)</p></li><li class="list__item" id="-o3vd0q_11"><p>and more</p></li></ul></section><section class="chapter"><h2 id="types" data-toc="types">Types</h2><p id="-o3vd0q_12">To enable MPS to assign types to nodes of your language, you should create a language aspect for the typesystem. The typesystem model for your language will be written in the typesystem language.</p><section class="chapter"><h3 id="-o3vd0q_1" data-toc="-o3vd0q_1">Concepts for types</h3><p id="-o3vd0q_13">Types are defined as ordinary concepts in MPS. Expressions (nodes) indicate their types by instantiating the type concepts in the type inference rules, such as in <code class="code" id="-o3vd0q_14">typeof(thisNode) :==: new node&lt;MyType&gt;</code> Some concepts carry the type information as their child, e.g. <em id="-o3vd0q_15">VariableDeclaration</em> in <em id="-o3vd0q_16">BaseLanguage</em>. <em id="-o3vd0q_17">Think of a type as a marker on a node that the typesystem assigns to it.</em></p><aside class="prompt" data-type="tip" data-title="" id="-o3vd0q_18"><p>It is not recommended to use the concepts of the language to represent types. Create dedicated type concepts.</p></aside><p id="-o3vd0q_19">Types can be freely combined into bigger types (e.g. type parameters). Not all concepts, however, may serve as types. It is advisable to avoid children in type concepts that would not be types themselves. That is because the type-system, when comparing two types, compares their contents for equality and only if the match is perfect it treats the nodes as the same type. Types are also generally independent of the storage, whereas ordinary nodes belong to some model.</p><p id="-o3vd0q_20">Some types do not need to hold any additional information. For example, the <em id="-o3vd0q_21">IntegerType</em> in <em id="-o3vd0q_22">BaseLanguage</em> is just an indicator that an expression represents a value of a numeric value - <code class="code" id="-o3vd0q_23">int a = 5;</code></p><p id="-o3vd0q_24">Some types may need to hold properties, children or references to other nodes, like e.g. <em id="-o3vd0q_25">ClassifierType</em> in <em id="-o3vd0q_26">BaseLanguage</em>, which represents a type defined by a class:</p><figure id="-o3vd0q_27"><img alt="ClassifierTypex1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/ClassifierTypex1.png" title="ClassifierTypex1.png" width="460" height="370"></figure><p id="-o3vd0q_28">Effectively the <em id="-o3vd0q_29">ClassifierType</em> is a term (node) that serves as an assertion that an expression typed with it, after it is evaluated, is an instance of that class.</p></section></section><section class="chapter"><h2 id="inferencerules" data-toc="inferencerules">Inference Rules</h2><p id="-o3vd0q_30">The main concept of the typesystem language is an <b id="-o3vd0q_31">inference rule</b>. An inference rule for a certain concept is mainly responsible for computing a type for instances of that concept.</p><p id="-o3vd0q_32">An inference rule consists of a condition and a body. A condition is used to determine whether a rule is applicable to a certain node. A <b id="-o3vd0q_33">condition</b> may be of two kinds: a <b id="-o3vd0q_34">concept reference</b> or a <b id="-o3vd0q_35">pattern</b>. A rule with a condition in the form of concept reference is applicable to every instance of that concept and its subconcepts. A rule with a pattern is applicable to nodes that match the pattern. A node matches a pattern if it has the same properties and references as the pattern, and if its children match the pattern's children. A pattern also may contain several variables which match everything.</p><p id="-o3vd0q_36">The <b id="-o3vd0q_37">body</b> of an inference rule is a list of statements which are executed when a rule is applied to a node. The main kind of statements of typesystem language are statements used for creating <b id="-o3vd0q_38">equations</b> and <b id="-o3vd0q_39">inequations</b> between types.</p><p id="-o3vd0q_40">An inference rule may define the <b id="-o3vd0q_41">overrides</b>&nbsp;block, which is a boolean flag that tells the typechecker that, in case there are other inference rules applicable to the superconcepts of the concept specified in the condition, this inference rule takes precedence, and all the rules for superconcepts are ignored. The version 3.3 brings possibility to use a code block instead of a static flag. Version 2021.3.3 introduces two new options:</p><ul class="list _bullet" id="-o3vd0q_42"><li class="list__item" id="-o3vd0q_43"><p id="-o3vd0q_44">An inference rule can be defined in an extending language and be applicable to a concept from the extended language.</p></li><li class="list__item" id="-o3vd0q_45"><p id="-o3vd0q_46">The overrides flag works for such inference rules in the extending language - it causes the rule to override all the rules defined for the superconcepts as well as the rules defined in the extended language for the particular concept.</p></li></ul><p id="-o3vd0q_47">it also covers situations where inference rules are defined for the same concept in languages that are being extended, in which case these original rules are also ignored.</p><p id="-o3vd0q_48">The inference rules that are applicable to instances of node attributes have additional features that allow for amending the rules applied to the attributed node. These can either be applied together with the attributed nodeâs inference rules or supersede them altogether. This, for example, can be used to implement alternate type inference based on presence conditions, which can take into account the parameters specified at the project or system level.</p><p id="-o3vd0q_49">In case an inference rule is applicable to a node attribute, there is also a possibility to tell the typechecker that this rule <b id="-o3vd0q_50">supercedes</b>&nbsp;the rules applicable to the attributed node, which are then ignored. Also, the attributed node is accessible in all rule's code blocks as <b id="-o3vd0q_51">attributedNode</b>.</p><section class="chapter"><h3 id="inferencemethods" data-toc="inferencemethods">Inference Methods</h3><p id="-o3vd0q_52">To avoid duplications, one may want to extract identical parts of code of several inference rules to a method. An inference method is just a simple Base Language method marked with an annotation "<code class="code" id="-o3vd0q_53">@InferenceMethod</code>". There are several language constructions you may use only inside inference rules and replacement rules and inference methods, they are: <b id="-o3vd0q_54">typeof</b>&nbsp;expressions, <b id="-o3vd0q_55">equations</b> and <b id="-o3vd0q_56">inequations</b>, <b id="-o3vd0q_57">when concrete</b>&nbsp;statements, <b id="-o3vd0q_58">type variable declarations</b> and <b id="-o3vd0q_59">type variable references</b>, and <b id="-o3vd0q_60">invocations of inference methods</b>. That is made for not to use such constructions in arbitrary methods, which may be called in arbitrary context, maybe not during type checking.</p></section></section><section class="chapter"><h2 id="equationsandinequations" data-toc="equationsandinequations">Equations And Inequations</h2><p id="-o3vd0q_61">The main process which is performed by the <b id="-o3vd0q_62">type-system engine</b> is the process of solving <b id="-o3vd0q_63">equations</b> and <b id="-o3vd0q_64">inequations</b> among all the types. A language designer tells the engine, which equations it should solve by writing them in <b id="-o3vd0q_65">inference rules</b>. To add an equation into an engine, the following statement is used:</p><p id="-o3vd0q_66"><code class="code" id="-o3vd0q_67">expr1 :==: expr2</code> where <code class="code" id="-o3vd0q_68">expr1</code> and <code class="code" id="-o3vd0q_69">expr2</code> are expressions, which evaluate to a <b id="-o3vd0q_70">node</b>.</p><p id="-o3vd0q_71">Consider the following use case. You want to say that the type of a local variable reference is equal to the type of the variable declaration it points to. So, you write <code class="code" id="-o3vd0q_72">typeof (varRef) :==: typeof (varRef.localVariableDeclaration)</code>, and that's all. The typesystem engine will solve such equations automatically.</p><p id="-o3vd0q_73">The above-mentioned expression <code class="code" id="-o3vd0q_74">typeof(expr)</code> (where <em id="-o3vd0q_75">expr</em> must evaluate to an MPS node) is a language construct, which returns a so-called type variable, which serves as a <b id="-o3vd0q_76">type</b> of that node. Type variables become <b id="-o3vd0q_77">concrete types</b> gradually during the process of equation solving.</p><p id="-o3vd0q_78">In certain situations you want to say that a certain type doesn't have to <b id="-o3vd0q_79">exactly equal another type</b>, but also may be a <b id="-o3vd0q_80">subtype</b> or a <b id="-o3vd0q_81">supertype</b> of that type. For instance, the type of the actual parameter of a method call does not necessarily have to be the same type as that of the method's formal parameter - it can be its subtype. For example, a method, which requires an Object as a parameter, may be applied also to a String.</p><p id="-o3vd0q_82">To express such a constraint, you may use an <b id="-o3vd0q_83">inequation</b> instead of an <b id="-o3vd0q_84">equation</b>. An inequation expresses the fact that a certain type should be a subtype of another type. It is written as follows: <code class="code" id="-o3vd0q_85">expr1 :&lt;=: expr2</code></p></section><section class="chapter"><h2 id="weakandstrongsubtyping" data-toc="weakandstrongsubtyping">Weak And Strong Subtyping</h2><p id="-o3vd0q_86">A relationship of subtyping is useful for several different cases. You want a type of an actual parameter to be a subtype of formal parameter type, or you want a type of an assigned value to be a subtype of variable's declared type; in method calls or field access operations you want a type of an operand to be a subtype of a method's declaring class.</p><p id="-o3vd0q_87">Sometimes such demands are somewhat controversial: consider, for instance, two types, int and Integer, which you want to be interchangeable when you pass parameters of such types to a method: if a method is <em id="-o3vd0q_88">doSomething(int i)</em>, it is legal to call <em id="-o3vd0q_89">doSomething(1)</em> as well as&nbsp; <em id="-o3vd0q_90">doSomething(new Integer(1))</em>. But when these types are used as types for operand of, say, a method call, the situation is the different: you shouldn't be able to call a method of an expression of type <em id="-o3vd0q_91">int</em>, of an integer constant for example. So, we have to conclude that in one sense <em id="-o3vd0q_92">int</em> and <em id="-o3vd0q_93">Integer</em> are subtypes of one another, while in the other sense they are not.</p><p id="-o3vd0q_94">For solving such a controversy, we introduce two relationships of subtyping: namely, <b id="-o3vd0q_95">weak</b> and <b id="-o3vd0q_96">strong</b> subtyping. Weak subtyping will follow from strong subtyping: <b id="-o3vd0q_97">if a node is a strong subtype of another node, then it is it's weak subtype also</b>.</p><p id="-o3vd0q_98">Then, we can say about our example, that int and Integer are weak subtypes of each other, but they are not strong subtypes. <b id="-o3vd0q_99">Assignment and parameters passing require weak subtyping only, method calls require strong subtyping</b>.</p><p id="-o3vd0q_100">When you create an inequation in you typesystem, you may choose it to be a strong or weak inequation. Also subtyping rules, those which state subtyping relationship (see below), can be either weak or strong. A weak inequation looks like <code class="code" id="-o3vd0q_101">:&lt;=:</code>, a strong inequation looks like <code class="code" id="-o3vd0q_102">:&lt;&lt;=:</code></p><p id="-o3vd0q_103">In most cases you want to state strong subtyping, and to check weak subtyping. If you are not sure, which subtyping you need, use weak one for inequations, strong one for subtyping rules.</p></section><section class="chapter"><h2 id="subtypingrules" data-toc="subtypingrules">Subtyping Rules</h2><p id="-o3vd0q_104">When the typesystem engine solves inequations, it requires information about whether a type is a subtype of another type. But how does the typesystem engine know about that? It uses <b id="-o3vd0q_105">subtyping rules</b>. Subtyping rules are used to express subtyping relationship between types. In fact, a subtyping rule is a function which, given a type, returns its immediate supertypes.</p><p id="-o3vd0q_106">A subtyping rule consists of a condition (which can be either a concept reference or a pattern) and a body, which is a list of statements that compute and return a node or a list of nodes that are immediate supertypes of the given node. When checking whether some type A is a supertype of another type B, the typesystem engine applies subtyping rules to B and computes its immediate supertypes, then applies subtyping rules to those supertypes and so on. If type A is among the computed supertypes of type B, the answer is "yes".</p><p id="-o3vd0q_107">By default, subtyping stated by subtyping rules is a strong one. If you want to state only weak subtyping, set "is weak" property of a rule to "true".</p></section><section class="chapter"><h2 id="comparisoninequationsandcomparisonrules" data-toc="comparisoninequationsandcomparisonrules">Comparison Inequations And Comparison Rules</h2><p id="-o3vd0q_108">Consider you want to write a rule for <em id="-o3vd0q_109">EqualsExpression</em> (operator <em id="-o3vd0q_110">==</em> in Java, BaseLanguage and some other languages): you want left operand and right operand of <em id="-o3vd0q_111">EqualsExpression</em> to be comparable, that is either type of a left operand should be a (non-strict) subtype of a right operand, or vice versa. To express this, you write a comparison inequation, in a form <em id="-o3vd0q_112">expr1 :~: expr2</em>, where <em id="-o3vd0q_113">expr1</em> and <em id="-o3vd0q_114">expr2</em> are expressions, which represent types. Such an inequation is fulfilled if <em id="-o3vd0q_115">expr1</em> is a subtype of <em id="-o3vd0q_116">expr2</em></p><div class="code-block" data-lang="none">(
                expr1 &lt;: expr2
                )
            </div><p id="-o3vd0q_118"><b id="-o3vd0q_119">or</b></p><div class="code-block" data-lang="none">
                expr2 &lt;: expr1
            </div><p id="-o3vd0q_121">Then, consider that, say, any Java interfaces should also be comparable, even if such interfaces are not subtypes of one another. That is because there always can be written a class, which implements both of interfaces, so variables of interface types can contain the same node, and variable of an interface type can be cast to any other interface. hence an <em id="-o3vd0q_122">equation</em>, <em id="-o3vd0q_123">cast</em>, or <em id="-o3vd0q_124">instanceof</em> expressions with both types being interface types should be legal (and, for example, in Java they are).</p><p id="-o3vd0q_125">To state such a comparability, which does not stem from subtyping relationships, you should use <b id="-o3vd0q_126">comparison rules</b>. A comparison rule consists of two conditions for the two applicable types and a body which returns true if the types are comparable or false if they are not.</p><p id="-o3vd0q_127">Here's the comparison rule for interface types:</p><p>comparison rule interfaces_are_comparable </p><div class="code-block" data-lang="none">
            applicable for concept = ClassifierType as classifierType1 , concept = ClassifierType as classifierType2
            applicable always
            overrides false
            rule {
              if (classifierType1.classifier.isInstanceOf(Interface) &amp;&amp;
              classifierType2.classifier.isInstanceOf(Interface)) {
                return true;
              } else {
                return false;
              }
            }
        </div></section><section class="chapter"><h2 id="quotations" data-toc="quotations">Quotations</h2><p id="-o3vd0q_129">A quotation is a language construct that lets you easily create a node with a required structure. Of course, you can create a node using the <em id="-o3vd0q_130">smodelLanguage</em>&nbsp;and then populate it with appropriate children, properties and references by hand, using the same <em id="-o3vd0q_131">smodelLanguage</em>. However, there's a simpler - and more visual - way to accomplish this.</p><p id="-o3vd0q_132">A quotation is an expression, whose value is the MPS node written inside the quotation. Think about a quotation as a "node literal", a construction similar to numeric constants and string literals. That is, you write a literal if you statically know what value do you mean. So inside a quotation you don't write an expression, which evaluates to a node, you rather write the node itself. For instance, an expression <code class="code" id="-o3vd0q_133">2 + 3</code> evaluates to <code class="code" id="-o3vd0q_134">5</code>, an expression <code class="code" id="-o3vd0q_135">&lt; 2 + 3 &gt;</code> (angled braces being quotation braces) evaluates to a node <em id="-o3vd0q_136">PlusExpression</em> with <em id="-o3vd0q_137">leftOperand</em> being an&nbsp;<em id="-o3vd0q_138">IntegerConstant 3</em> and <em id="-o3vd0q_139">rightOperand</em> being <em id="-o3vd0q_140">IntegerConstant 5</em>.</p><p id="-o3vd0q_141">(See the <a href="quotations.html" id="-o3vd0q_142">Quotations</a> documentation for more details on quotations, anti quotations and light quotations)</p></section><section class="chapter"><h2 id="antiquotations" data-toc="antiquotations">Antiquotations</h2><p id="-o3vd0q_143">For it is a literal, a value of quotation should be known statically. On the other hand, in cases when you know some parts (i.e. children, referents or properties) of your node only dynamically, i.e. those parts that can only be evaluated at runtime and are not known at design time, then you can't use just a quotation to create a node with such parts.</p><p id="-o3vd0q_144">The good news, however, is that if you know the most part of a node statically and you want to replace only several parts by dynamically-evaluated nodes you can use <b id="-o3vd0q_145">antiquotations</b>. An antiquotation can be of 4 types: <em id="-o3vd0q_146">child</em>, <em id="-o3vd0q_147">reference</em>, <em id="-o3vd0q_148">property</em> and <em id="-o3vd0q_149">list</em> antiquotation. They all contain an expression, which evaluates dynamically to replace a part of the quoted node by its result. Child and referent antiquotations evaluate to a node, property antiquotation evaluates to string and list antiquotation evaluates to a list of nodes.</p><p id="-o3vd0q_150">For instance, you want to create a <em id="-o3vd0q_151">ClassifierType</em> with the class <em id="-o3vd0q_152">ArrayList</em>, but its type parameter is known only dynamically, for instance by calling a method, say, "computeMyTypeParameter()".</p><p id="-o3vd0q_153">Thus, you write the following expression: <em id="-o3vd0q_154">&lt; ArrayList &lt; %( computeMyTypeParameter() )% &gt; &gt;</em>. The construction <em id="-o3vd0q_155">%(...)%</em> here is a node antiquotation.</p><p id="-o3vd0q_156">You may also antiquotate reference targets and property values, with <em id="-o3vd0q_157">^(...)^</em> and <em id="-o3vd0q_158">$(...)$</em>, respectively; or a list of children of one role, using <em id="-o3vd0q_159">*(...)*</em>.</p><p id="-o3vd0q_160">a) If you want to replace a node somewhere inside a quoted node with a node evaluated by an expression, you use node antiquotation, that is %( )%. As you may guess there's no sense to replace the whole quoted node with an antiquotation with an expression inside, because in such cases you could instead write such an expression directly in your program.</p><p id="-o3vd0q_161">So node antiquotations are used to replace children, grandchildren, great-grandchildren and other descendants of a quoted node. Thus, an expression inside of antiquotation should return a node. To write such an antiquotation, place the caret in a cell for a child and type "%".</p><p id="-o3vd0q_162">b) If you want to replace a target of a reference from somewhere inside a quoted node with a node evaluated by an expression, you use reference antiquotation, that is ^(...)^ . To write such an antiquotation, place the caret in a cell for a referent and type "^".</p><p id="-o3vd0q_163">c) If you want to replace a child (or some more deeply located descendant), which is of a multiple-cardinality role, and if for that reason you may want to replace it not with a single node but rather with several ones, then use child list (simply list for brevity) antiquotations, *( )* <b id="-o3vd0q_164">.</b>An expression inside a list antiquotation should return a list of nodes, that is of type <em id="-o3vd0q_165">nlist&lt;..&gt;</em> or compatible type (i.e. <em id="-o3vd0q_166">list&lt;node&lt;..&gt;&gt;</em> is ok, too, as well as some others). To write such an antiquotation, place the caret in a cell for a child inside a child collection and type "*" . You cannot use it on an empty child collection, so before you press "*" you have to enter a single child inside it.</p><p id="-o3vd0q_167">d) If you want to replace a property value of a quoted node by a dynamically calculated value, use property antiquotation $( )$. An expression inside a quotation should return string, which will be a value for an antiquoted property of a quoted node. To write such an antiquotation, place the caret in a cell for a property and type "$".</p><p id="-o3vd0q_168">(See the&nbsp;<a href="quotations.html" id="-o3vd0q_169">Quotations</a>&nbsp;documentation for more details on quotations, anti quotations and light quotations)</p></section><section class="chapter"><h2 id="examplesofinferencerules" data-toc="examplesofinferencerules">Examples Of Inference Rules</h2><p id="-o3vd0q_170">Here are the simplest basic use cases of an inference rule:</p><ul class="list _bullet" id="-o3vd0q_171"><li class="list__item" id="-o3vd0q_172"><p id="-o3vd0q_173">to assign the same type to all instances of a concept (useful mainly for literals):</p><div class="code-block" data-lang="none">
                    applicable to concept = StringLiteral as nodeToCheck
                    {
                    typeof (nodeToCheck) :==: &lt;String&gt;
                    }
                </div></li><li class="list__item" id="-o3vd0q_175"><p id="-o3vd0q_176">to equate a type of a declaration and the references to it (for example, for variables and their usages):</p><div class="code-block" data-lang="none">
                    applicable to concept = VariableReference as nodeToCheck
                    {
                    typeof (nodeToCheck) :==: typeof (nodeToCheck.variableDeclaration)
                    }
                </div></li><li class="list__item" id="-o3vd0q_178"><p id="-o3vd0q_179">to give a type to a node with a type annotation (for example, type of a variable declaration):</p><div class="code-block" data-lang="none">
                    applicable to concept = VariableDeclaration as nodeToCheck
                    {
                    typeof (nodeToCheck) :==: nodeToCheck.type
                    }
                </div></li><li class="list__item" id="-o3vd0q_181"><p id="-o3vd0q_182">to establish a restriction for a type of a certain node: useful for actual parameters of a method, an initializer of a type variable, the right-hand part of an assignment, etc.</p><div class="code-block" data-lang="none">
                    applicable to concept = AssignmentExpression as nodeToCheck
                    {
                    typeof (nodeToCheck.rValue) :&lt;=: typeof (nodeToCheck.lValue)
                    }
                </div></li></ul></section><section class="chapter"><h2 id="typevariables" data-toc="typevariables">Type Variables</h2><p id="-o3vd0q_184">Inside the typesystem engine during type evaluation, a type may be either a concrete type (a node) or a so-called <b id="-o3vd0q_185">type variable</b>. Also, it may be a node which contains some type variables as its children or further descendants. A type variable represents an undefined type, which may then become a concrete type, as a result of solving equations that contain this type variable.</p><p id="-o3vd0q_186">Type variables appear at runtime mainly as a result of the "typeof" operation, but you can create them manually, if you want to. There's a statement called <em id="-o3vd0q_187">TypeVarDeclaration</em> in the typesystem lanuage to do so. You write it like "var T" or "var X" or "var V", i.e. "var" followed by the name of a type variable. Then you may use your variable, for example, in antiquotations to create a node with type variables inside.</p><p id="-o3vd0q_188">Example: an inference rule for "for each" loop. A "for each" loop in Java consists of a loop body, an iterable to iterate over, and a variable into which the next member of an iterable is assigned before the next iteration. An iterable should be either an instance of a subclass of the Iterable interface, or an array. To simplify the example, we don't consider the case of the iterable being an array. Therefore, we need to express the following: <em id="-o3vd0q_189">an iterable's type should be a subtype of an Iterable of something</em>, and <em id="-o3vd0q_190">the variable's type should be a supertype of that very something</em>. For instance, you can write the following:</p><div class="code-block" data-lang="none">
            for (String s : new ArrayList&lt;String&gt;(...)) {
            ...
            }
        </div><p id="-o3vd0q_192">or the following:</p><div class="code-block" data-lang="none">
            for (Object o : new ArrayList&lt;String&gt;(...)) {
            ...
            }
        </div><p id="-o3vd0q_194">Iterables in both examples above have the type <em id="-o3vd0q_195">ArrayList&lt;String&gt;</em>, which is a subtype of <em id="-o3vd0q_196">Iterable&lt;String&gt;</em>. Variables have types <em id="-o3vd0q_197">String</em> and <em id="-o3vd0q_198">Object</em>, respectively, both of which are subtypes of <em id="-o3vd0q_199">String</em>.</p><p id="-o3vd0q_200">As we see, an iterable's type should be a subtype of an <em id="-o3vd0q_201">Iterable</em> of something, and the variable's type should be a supertype of that very something. But how to say "that very something" in the typesystem language? The answer is, it's a type variable that we use to express the link between the type of an iterable and the type of a variable. So we write the following inference rule:</p><div class="code-block" data-lang="none">
            applicable for concept = ForeachStatement as nodeToCheck
            {
            var T;
            typeof(nodeToCheck.iterable) :&lt;=: Iterable &lt; %( T )% &gt;;
            typeof(nodeToCheck.variable) :&gt;=: T;
            }
        </div></section><section class="chapter"><h2 id="meetandjointypes" data-toc="meetandjointypes">Meet and Join types</h2><p id="-o3vd0q_203"><em id="-o3vd0q_204">Meet</em> and <em id="-o3vd0q_205">Join</em> types are special types, which are treated differently by the typesystem engine. Technically <em id="-o3vd0q_206">Meet</em> and <em id="-o3vd0q_207">Join</em> types are instances of <em id="-o3vd0q_208">MeetType</em> and <em id="-o3vd0q_209">JoinType</em> concepts, respectively. They may have an arbitrary number of argument types, which could be any nodes. Semantically, a <em id="-o3vd0q_210">Join</em> type is a type, which is a supertype of all its arguments, and a node which has a type <em id="-o3vd0q_211">Join(T1|T2|..Tn)</em> can be regarded as if it had type T1 or type T2 or... or type Tn. A <em id="-o3vd0q_212">Meet</em> type is a type, which is a subtype of its every argument, so one can say that a node, which has a type <em id="-o3vd0q_213">Meet(T1&amp;T2&amp;..&amp;Tn)</em> inhabits type T1 and type T2 and.. and type Tn. The separators of arguments of the&nbsp;<em id="-o3vd0q_214">Join</em> and <em id="-o3vd0q_215">Meet</em> types (i.e. "|" and "&amp;") are chosen respectively to serve as a mnemonics.</p><p id="-o3vd0q_216">Meet and Join types are very useful at certain situations. Meet types appear even in MPS <em id="-o3vd0q_217">BaseLanguage</em> (which is very close to Java). For instance, the type of such an expression:</p><div class="code-block" data-lang="none">
            true ? new Integer(1) : "hello"
        </div><p id="-o3vd0q_219">is <em id="-o3vd0q_220">Meet(Serializable &amp; Comparable)</em>, because both Integer (the type of <em id="-o3vd0q_221">new Integer(1)</em>) and <em id="-o3vd0q_222">String</em> (the type of "hello") implement both <em id="-o3vd0q_223">Serializable</em> and <em id="-o3vd0q_224">Comparable</em>.</p><p id="-o3vd0q_225">Join type is useful when, say, you want some function-like concept return values of two different types (node or list of nodes, for instance). Then you should make type of its invocation be <em id="-o3vd0q_226">Join(node&lt;&gt; | list&lt;node&lt;&gt;&gt;)</em>.</p><p id="-o3vd0q_227">You can create <em id="-o3vd0q_228">Meet</em> and <em id="-o3vd0q_229">Join</em> types by yourself, if you need to. Use <b id="-o3vd0q_230">quotations</b> to create them, just as with other types and other nodes. The concepts of <em id="-o3vd0q_231">Meet</em> and <em id="-o3vd0q_232">Join</em> types are <em id="-o3vd0q_233">MeetType</em> and <em id="-o3vd0q_234">JoinType</em>, as it is said above.</p></section><section class="chapter"><h2 id="&quot;whenconcrete&quot;blocks" data-toc="&quot;whenconcrete&quot;blocks">"When Concrete" Blocks</h2><p id="-o3vd0q_235">Sometimes you may want not only to write equations and inequations for a certain types, but to perform some complex analysis with type structure. That is, inspect inner structure of a concrete type: its children, children of children, referents, etc.</p><p id="-o3vd0q_236">It may seem that one just may write typeof(some expression), and then analyze this type. The problem is, however, that one can't just inspect a result of "typeof" expression because it may be a type variable at that moment. Although a type variable usually will become a concrete type at some moment, it can't be guaranteed that it is concrete in some given point of your typesystem code.</p><p id="-o3vd0q_237">To solve such a problem you can use a "when concrete" block.</p><div class="code-block" data-lang="none">
            when concrete ( expr as var ) {
              body
            }
        </div><p id="-o3vd0q_239">Here, "expr" is an expression which will evaluate to a mere <em id="-o3vd0q_240">type</em> you want to inspect (not to a node type of which you want to inspect), and "var" is a variable to which an expression will be assigned. Then this variable may be used inside a body of "when concrete" block. A body is a list of statements which will be executed only when a type denoted by "expr" becomes concrete, thus inside the body of a when concrete block you may safely inspect its children, properties, etc. if you need to.</p><p id="-o3vd0q_241">If you have written a when concrete block and look into its inspector you will see two options: "is shallow" and "skip error". If you set "is shallow" to "true", the body of your when concrete block will be executed when expression becomes shallowly concrete, i.e. becomes not a type variable itself but possibly has type variables as children or referents. Normally, if your expression in condition of when concrete block is never concrete, then an error is reported. If it is normal for a type denoted by your expression to never become a concrete type, you can disable such error reporting by setting "skip error" to true.</p></section><section class="chapter"><h2 id="overloadedoperators" data-toc="overloadedoperators">Overloaded Operators</h2><p id="-o3vd0q_242">Sometimes an operator (like +, -, etc.) has different semantics when applied to different values. For example, + in Java means addition when applied to numbers, and it means string concatenation if one of its operands is of type <em id="-o3vd0q_243">String</em>. When the semantics of an operator depends on the types of its operands, it's called <b id="-o3vd0q_244">operator overloading</b>. In fact, we have many different operators denoted by the same syntactic construction.</p><p id="-o3vd0q_245">Let's try to write an inference rule for a plus expression. First, we should inspect the types of operands, because if we don't know the types of operands (whether they are numbers or Strings), we cannot choose the type for an operation (it will be either a number or a <em id="-o3vd0q_246">String</em>). To be sure that types of operands are concrete we'll surround our code with two when concrete blocks, one for left operand's type and another one for right operand's type.</p><div class="code-block" data-lang="none">
            when concrete(typeof(plusExpression.leftExpression) as leftType) {
            when concrete(typeof(plusExpression.rightExpression) as rightType) {
            ...
            }
        </div><p>} </p><p id="-o3vd0q_248">Then, we can write some inspections, where we check whether our types are strings or numbers and choose an appropriate type of operation. But there will be a problem here: if someone writes an extension of <em id="-o3vd0q_249">BaseLanguage</em>, where they want to use the plus expression for addition of some other entities, say, matrices or dates, they won't be able to use plus expression because types for plus expression are hard-coded in the already existing inference rule. So, we need an <b id="-o3vd0q_250">extension point</b> to allow language-developers to <b id="-o3vd0q_251">overload existing binary operations</b>.</p><p id="-o3vd0q_252">Typesystem language has such an extension point. It consists of:</p><ul class="list _bullet" id="-o3vd0q_253"><li class="list__item" id="-o3vd0q_254"><p>overloading operation rules and</p></li><li class="list__item" id="-o3vd0q_255"><p>a construct which provides a type of operation by operation and types of its operands.</p></li></ul><p id="-o3vd0q_256">For instance, a rule for <em id="-o3vd0q_257">PlusExpression</em> in <em id="-o3vd0q_258">BaseLanguage</em> is written as follows:</p><div class="code-block" data-lang="none">
            when concrete(typeof(plusExpression.leftExpression) as leftType) {
              when concrete(typeof(plusExpression.rightExpression) as rightType) {
                node&lt;&gt; opType = operation type( plusExpression , leftType , rightType );
                if (opType.isNotNull) {
                  typeof(plusExpression) :==: opType;
                } else {
                  error "+ can't be applied to these operands" -&gt; plusExpression;
                }
              }
            }
        </div><p id="-o3vd0q_260">Here, "operation type" is a construct which provides a type of an operation according to types of operation's left operand's type, right operand's type and the operation itself. For such a purpose it uses overloading operation rules.</p><section class="chapter"><h3 id="overloadedoperationrules" data-toc="overloadedoperationrules">Overloaded Operation Rules</h3><p id="-o3vd0q_261">Overloaded operation rules reside within a root node of concept <em id="-o3vd0q_262">OverloadedOpRulesContainer</em>. Each overloaded operation rule consists of:</p><ul class="list _bullet" id="-o3vd0q_263"><li class="list__item" id="-o3vd0q_264"><p>an applicable operation concept, i.e. a reference to a concept of operation to which a rule is applicable (e.g. <em id="-o3vd0q_265">PlusExpression</em>);</p></li><li class="list__item" id="-o3vd0q_266"><p>left and right operand type restrictions, which contain a type which restricts a type of left/right operand, respectively. A restriction can be either exact or not, which means that a type of an operand should be exactly a <b id="-o3vd0q_267">type</b> in a restriction (if the restriction is exact), or its <b id="-o3vd0q_268">subtype</b> (if not exact), for a rule to be applicable to such operand types;</p></li><li class="list__item" id="-o3vd0q_269"><p>a function itself, which returns a type of the operation knowing the operation concept and the left and right operand types.</p></li></ul><p id="-o3vd0q_270">Here's an example of one of overloading operation rules for <em id="-o3vd0q_271">PlusExpression</em> in <em id="-o3vd0q_272">BaseLanguage</em>:</p><div class="code-block" data-lang="none">
                operation concept: PlusExpression
                left operand type: &lt;Numeric&gt;.descriptor is exact: false
                right operand type: &lt;Numeric&gt;.descriptor is exact: false
                operation type:

                (operation, leftOperandType, rightOperandType)-&gt;node&lt; &gt; {
                  if (leftOperandType.isInstanceOf(NullType) || rightOperandType.isInstanceOf(NullType)) {
                    return null;
                  } else {
                    return Queries.getBinaryOperationType(leftOperandType, rightOperandType);
                  }
                }
            </div></section></section><section class="chapter"><h2 id="replacementrules" data-toc="replacementrules">Replacement Rules</h2><section class="chapter"><h3 id="motivation" data-toc="motivation">Motivation</h3><p id="-o3vd0q_274">Consider the following use case: you have types for functions in your language, e.g. (a <sub class="subscript" id="-o3vd0q_275">1</sub>, a <sub class="subscript" id="-o3vd0q_276">2</sub> ,...a <sub class="subscript" id="-o3vd0q_277">N</sub>) -&gt; r, where a <sub class="subscript" id="-o3vd0q_278">1</sub>, a <sub class="subscript" id="-o3vd0q_279">2</sub>, .., a <sub class="subscript" id="-o3vd0q_280">N</sub>, and r are types: a <sub class="subscript" id="-o3vd0q_281">K</sub> is a type of K-th function argument and r is a type of a result of a function. Then you want to say that your function types are <em id="-o3vd0q_282">covariant</em> by their return types and <em id="-o3vd0q_283">contravariant</em> by their argument types. That is, a function type F = (T <sub class="subscript" id="-o3vd0q_284">1</sub>, .., T <sub class="subscript" id="-o3vd0q_285">N</sub>) -&gt; R is a subtype of a function type G = (S <sub class="subscript" id="-o3vd0q_286">1</sub>, .., S <sub class="subscript" id="-o3vd0q_287">N</sub>) -&gt; Q (written as F &lt;: G) if and only if R &lt;: Q (covariant by return type) and for any K from 1 to N, T <sub class="subscript" id="-o3vd0q_288">K</sub> :&gt; S <sub class="subscript" id="-o3vd0q_289">K</sub> (that is, contravariant by arguments types).</p><p id="-o3vd0q_290">The problem is, how to express covariance and contravariance in the typesystem language? Using subtyping rules you may express covariance by writing something like this:</p><div class="code-block" data-lang="none">
                nlist&lt;&gt; result = new nlist&lt;&gt;;
                for (node&lt;&gt; returnTypeSupertype : immediateSupertypes(functionType.returnType) ) {
                  node &lt;FunctionType&gt; ft = functionType.copy;
                  ft.returnType = returnTypeSupertype;
                  result.add(ft);
                }
                return result;
            </div><p id="-o3vd0q_292">Okay, we have collected all immediate supertypes for a function's return type and have created a list of function types with those collected types as return types and with original argument types. But, first, if we have many supertypes of return type, it's not very efficient to perform such an action each time we need to solve an inequation, and second, although now we have covariance by function's return type, we still don't have contravariance by function's arguments' types. We can't collect immediate subtypes of a certain type because subtyping rules give us supertypes, not subtypes.</p><p id="-o3vd0q_293">In fact, we just want to express the abovementioned property: F = (T <sub class="subscript" id="-o3vd0q_294">1</sub>, .., T <sub class="subscript" id="-o3vd0q_295">N</sub>) -&gt; R &lt;: G = (S <sub class="subscript" id="-o3vd0q_296">1</sub>, .., S <sub class="subscript" id="-o3vd0q_297">N</sub>) -&gt; Q (written as F &lt;: G) if and only if R &lt;: Q and for any K from 1 to N, T <sub class="subscript" id="-o3vd0q_298">K</sub> :&gt; S <sub class="subscript" id="-o3vd0q_299">K</sub>. For this and similar purposes the typesystem language has a notion called "replacement rule."</p><p id="-o3vd0q_300">A replacement rule can be overridden by another, more specific replacement rule defined in the same language or one of the extending languages. In case there are two candidate replacement rules that can be applied for a given pair of left and right types, the one that is specified with a more specific concept, either for the left or right type, wins. <br> Additionally, in case two or more rules are matching and all specify exactly same concepts, the one defined in a more specific language wins. The "overrides" condition is checked before a rule is selected for a particular combination of right and left concepts, and is defined to be false by default. If true, all rules that correspond to less specific matching conditions are eliminated from the applicability scope.</p></section><section class="chapter"><h3 id="what'sareplacementrule?" data-toc="what'sareplacementrule?">What's a replacement rule?</h3><p id="-o3vd0q_302">A replacement rule provides a convenient way to solve inequations. While the standard way is to transitively apply subtyping rules to a should-be-subtype until a should-be-supertype is found among the results (or is never found among the results), a replacement rule, if applicable to an inequation, removes the inequation and then executes its body (which usually contains "create equation" and "create inequation" statements).</p><p id="-o3vd0q_303">Applicability of a replacement rule is decided based on:</p><ul class="list _bullet" id="-o3vd0q_304"><li class="list__item" id="-o3vd0q_305"><p>The <b id="-o3vd0q_306">applicable for</b> section, then defines the matching sub-typing relationship between two concepts.</p></li><li class="list__item" id="-o3vd0q_307"><p>The <b id="-o3vd0q_308">custom condition</b> section, which is a boolean function calculating applicability arbitrarily from the two processed types.</p></li><li class="list__item" id="-o3vd0q_309"><p>The <b id="-o3vd0q_310">overrides</b> flag, which alows a rule to override a rule defined for a sub-concept. If true, all rules that correspond to less specific matching conditions are eliminated from the applicability scope.</p></li></ul></section><section class="chapter"><h3 id="examples" data-toc="examples">Examples</h3><p id="-o3vd0q_311">A replacement rule for above-mentioned example is written as follows:</p><div class="code-block" data-lang="none">
                replacement rule FunctionType_subtypeOf_FunctionType
                applicable for concept = FunctionType as functionSubType &lt;: concept = FunctionType as functionSuperType
                custom condition: true
                overrides: false

                rule {
                  if (functionSubType.parameterType.count != functionSuperType.parameterType.count) {
                    error " different parameter numbers " -&gt; equationInfo.getNodeWithError();
                    return;
                  }
                  functionSubType.returnType :&lt;=: functionSuperType.returnType;
                  foreach (node&lt;&gt; paramType1 : functionSubType.parameterType;
                    node&lt;&gt; paramType2 : functionSuperType.parameterType ) {
                    paramType2 :&lt;=: paramType1;
                  }
                }
            </div><p id="-o3vd0q_313">Here we say that a rule is applicable to a should-be-subtype of concept FunctionType and a should-be-supertype of concept FunctionType. The body of a rule ensures that the number of parameter types of function types are equal, otherwise it reports an error and returns. If the numbers of parameter types of both function types are equal, a rule creates an inequation with return types and appropriate inequation for appropriate parameter types.</p><p id="-o3vd0q_314">Another simple example of replacement rules usage is a rule, which states that a Null type (a type of null literal) is a subtype of every type except primitive ones. Of course, we can't write a subtyping rule for Null type, which returns a list of <b id="-o3vd0q_315">all</b> types. Instead, we write the following replacement rule:</p><div class="code-block" data-lang="none">
                replacement rule any_type_supertypeof_nulltype

                applicable for concept = NullType as nullType &lt;: concept = BaseConcept as baseConcept
                custom condition: true
                overrides: false

                rule {
                  if ( baseConcept.isInstanceOf ( PrimitiveType ) ) {
                    error "null type is not a subtype of primitive type " -&gt; equationInfo.getNodeWithError();
                  }
                }
            </div><p id="-o3vd0q_317">This rule is applicable to any should-be-supertype and to those should-be-subtypes which are Null types. The only thing this rule does is checking whether should-be-supertype is an instance of PrimitiveType concept. If it is, the rule reports an error. If is not, the rule does nothing, therefore the inequation to solve is simply removed from the typesystem engine with no further effects.</p></section><section class="chapter"><h3 id="differentsemantics" data-toc="differentsemantics">Different semantics</h3><p id="-o3vd0q_318">A semantic of a replacement rule, as explained above, is to replace an inequation with some other equations and inequations or to perform some other actions when applied. This semantic really doesn't state that a certain type is a subtype of another type under some conditions. It just defines how to solve an inequation with those two types.</p><p id="-o3vd0q_319">For example, suppose that during generation you need to inspect whether some statically unknown type is a subtype of String. What will an engine answer when a type to inspect is Null type? When we have an inequation, a replacement rule can say that it is true, but for this case its abovementioned semantics is unuseful: we have no inequations, we have a question to answer yes or no. With function types, it is worse because a rule says that we should create some inequations. So, what do we have to do with them in our use case?</p><p id="-o3vd0q_320">To make replacement rules usable when we want to inspect whether a type is a subtype of another type, a different semantic is given to replacement rules in such a case.</p><p id="-o3vd0q_321">This semantic is as follows: each "add equation" statement is treated as an inspection of whether two nodes match; each "add inequation" statement is treated as an inspection of whether one node is a subtype of another; each report error statement is treated as "return false."</p><p id="-o3vd0q_322">Consider the above replacement rule for function types:</p><div class="code-block" data-lang="none">
                replacement rule FunctionType_subtypeOf_FunctionType
                applicable for concept = FunctionType as functionSubType &lt;: concept = FunctionType as functionSuperType
                custom condition: true
                overrides: false

                rule {
                  if (functionSubType.parameterType.count != functionSuperType.parameterType.count) {
                    error " different parameter numbers " -&gt; equationInfo.getNodeWithError();
                    return;
                  }
                  functionSubType.returnType :&lt;=: functionSuperType.returnType;
                  foreach (node&lt;&gt; paramType1 : functionSubType.parameterType; node&lt;&gt; paramType2 : functionSuperType.parameterType ) {
                    paramType2 :&lt;=: paramType1;
                  }
                }
            </div><p id="-o3vd0q_324">In a different semantic, it will be treated as follows:</p><div class="code-block" data-lang="none">
                boolean result = true;
                if ( functionSubType.parameterType.count != functionSuperType.parameterType.count ) {
                  result = false;
                  return result;
                }
                result = result &amp;&amp; isSubtype( functionSubType.returnType &lt;: functionSuperType.returnType );
                foreach ( node&lt;&gt; paramType1 : functionSubType.parameterType; node&lt;&gt; paramType2 : functionSuperType.parameterType ) {
                  result = result &amp;&amp; isSubtype (paramType2 &lt;: paramType1);
                }
                return result;
            </div><p id="-o3vd0q_326">So, as we can see, the other semantic is quite an intuitive mapping between creating equations/inequations and performing inspections.</p></section></section><section class="chapter"><h2 id="type-system,trace" data-toc="type-system,trace">Type-system, trace</h2><p id="-o3vd0q_327">MPS provides a handy debugging tool that gives you insight into how the type-system engine evaluates the type-system rules on a particular problem and calculates the types. You invoke it from the context menu or by a keyboard shortcut Control/Cmd + Shift + X:</p><figure id="-o3vd0q_328"><img alt="TST2.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/TST2.png" title="TST2.png" width="732" height="537"></figure><p id="-o3vd0q_329">The console has two panels. The one on the left shows the sequence or rules as they were applied, while the one on the right gives you a snapshot of the type-system engine's working memory at the time of evaluating the rule selected in the left panel:</p><figure id="-o3vd0q_330"><img alt="TST1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/TST1.png" title="TST1.png" width="873" height="499"></figure><p id="-o3vd0q_331">Type errors are marked inside the Type-system Trace panel with red color:</p><figure id="-o3vd0q_332"><img alt="TST3.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/TST3.png" title="TST3.png" width="797" height="188"></figure><p id="-o3vd0q_333">Additionally, if you spot an error in your code, use <em id="-o3vd0q_334">Control + Alt + Click / Cmd + Alt + Click</em>&nbsp;to navigate quickly to the rule that fails to validate the types:</p><figure id="-o3vd0q_335"><img alt="TST4.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/TST4.png" title="TST4.png" width="544" height="308"></figure><figure id="-o3vd0q_336"><img alt="TST5.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/TST5.png" title="TST5.png" width="421" height="311"></figure></section><section class="chapter"><h2 id="advancedfeaturesoftypesystemlanguage" data-toc="advancedfeaturesoftypesystemlanguage">Advanced features of typesystem language</h2><section class="chapter"><h3 id="overridingdefaulttypenode" data-toc="overridingdefaulttypenode">Substituting default type node</h3><p id="-o3vd0q_337">When type is assigned to a program node as a result of either applying an equation or resolving an inequality, the node to represent type is taken as is by default. That is to say, it may be a node in the program or be created with a quotation. In both cases, the result of evaluating the expression that specifies type to be assigned by either equation or inequality statement, literally represents target type. This feature allows to substitute another node to represent type instead.</p><p id="-o3vd0q_338">For example, one might decide to use different types for different program configurations, such as using <code class="code" id="-o3vd0q_339">int</code> or <code class="code" id="-o3vd0q_340">long</code> depending on whether the task requires using one type or another. This is different from simply using the generator to produce the correct "implementation" type, as the substitution is done at the time the typechecking is performed, so possible errors can be caught early.</p><p id="-o3vd0q_341">In its simplest form the type substitution can be used by creating an instance of <code class="code" id="-o3vd0q_342">Substitute Type Rule</code> in the typesystem model.</p><div class="code-block" data-lang="none">
                substitute type rule substituteType_MyType {
                applicable for concept = MyType as mt

                  substitute {
                    if (mt.isConditionSatisfied()) {
                      return new node&lt;IntegerType&gt;;
                    }
                    return null;
                  }
                }
            </div><p id="-o3vd0q_344">The <code class="code" id="-o3vd0q_345">Substitute Type Rule</code> is applicable to nodes that represent types. Whenever a new type is introduced by the typechecker, it searches for applicable substitution rules and executes them.&nbsp;The rule must either return an instance of `node&lt;&gt;` as the substitution, or null value, in which case the original node is used to represent the type (the default behaviour).</p><p id="-o3vd0q_346">One other possibility to overrides types used by the typechecker comes with the use of node attributes. If there is a node attribute contained by the original type node, the typechecker tries to find a Substitute Type Rule applicable to the attribute first. This way one can override the type nodes even for languages, which implementation is sealed.</p><div class="code-block" data-lang="none">
                substitute type rule substituteType_SubstituteAnnotation {
                applicable for concept = SubstituteAnnotation as substituteAnnotation

                  substitute {
                    if (substituteAnnotation.condition.isSatisfied(attributedNode)) {
                      return substituteAnnotation.substitute;
                    }
                    return null;
                  }
                }
            </div><p id="-o3vd0q_348">The rule above is defined for the attribute node, and it's the attribute node that is passed to the rule as the explicit parameter. The rule can check whether the condition for substituting the type node is satisfied, and it can also access the attributed node representing original type via <code class="code" id="-o3vd0q_349">attributedNode</code> expression.</p><p id="-o3vd0q_350">One caveat that should be mentioned, concerns the case when a type node just returned from a substitute rule, is itself a subject to another substitution. The typechecker tries to apply all matching substitution rules exhaustively, until no more substitutions are available. Only then the type appears in the internal model of the typechecker. Some precautions are taken to prevent the typechecker from going into an endless cycle of substitutions, such as A -&gt; B -&gt; A, but these are not perfect and one should be careful so as to not to introduce infinite cycles.</p></section><section class="chapter"><h3 id="check-onlyinequations" data-toc="check-onlyinequations">Check-only inequations</h3><p id="-o3vd0q_351">Basically, inequations may affect nodes' types, for instance if one of the inequation part is a type variable, it may become a concrete type because of this inequation. But, sometimes one does not want a certain inequation to create types, only to check whether such an inequation is satisfied. We call such inequations check-only inequations. To mark an inequation as a check-only, one should go to this inequation's inspector and should set a flag "check-only" to "true". To visually distinguish such inequations, the "less or equals" sign for check-only inequation is gray, while for normal ones it is black, so you can see whether an inequation is check-only without looking at its inspector.</p></section><section class="chapter"><h3 id="dependencies" data-toc="dependencies">Dependencies</h3><p id="-o3vd0q_352">When writing a generator for a certain language (see generator), one may want to ask for a type of a certain node in generator queries. When generator generates a model, such a query will make typesystem engine do some typechecking to find out the type needed. Performing full typechecking of a node's containing root to obtain the node's type is expensive and almost always unnecessary. In most cases, the typechecker should check only the node given. In more difficult cases, obtaining the type of a given node may require checking its parent or maybe a further ancestor. The typechecking engine will check a given node if the computed type is not fully concrete (i.e. contains one or more type variables); then the typechecker will check the node's parent, and so on.</p><p id="-o3vd0q_353">Sometimes there's an even more complex case: the type of a certain node being computed in isolation is fully concrete; and the type of the same node - in a certain environment - is fully concrete also, but differs from the first one. In such a case, the abovementioned algorithm will break, returning the type of an node as if being isolated, which is not the correct type for the given node.</p><p id="-o3vd0q_354">To solve this kind of problem, you can give some hints to the typechecker. Such hints are called dependencies - they express a fact that a node's type depends on some other node. Thus, when computing a type of a certain node during generation, if this node has some dependencies they will be checked also, so the node will be type-checked in an appropriate environment. A dependency is expressed by using the typeOf expression on the node, the type of which is needed for proper computation of the requested type.</p></section></section><section class="chapter"><h2 id="overridingtypeofliteralorexpression" data-toc="overridingtypeofliteralorexpression">Overriding type of literal or expression</h2><p id="-o3vd0q_355">In addition to type substitution rules, which are only applicable to types, we introduce support for attributes in the inference rules.</p><section class="chapter"><h3 id="inferencerules-1" data-toc="inferencerules-1">Inference rules</h3><p id="-o3vd0q_356">Literals or expressions usually have associated type inference rules that get triggered when the typechecker requires type of the node in question. The rules have a mechanism allowing subconcepts to extend or override the predefined rule.</p><div class="code-block" data-lang="none">
                rule typeof_IntLiteral { applicable for concept = IntLiteral as nodeToCheck
                applicable always
                overrides true
                  do {
                    typeof(nodeToCheck) :==: &lt;integer&gt;;
                  }
                }
            </div></section><section class="chapter"><h3 id="inferencerulesfornodeattributes" data-toc="inferencerulesfornodeattributes">Inference rules for node attributes</h3><p id="-o3vd0q_358">If a node has one or more attributes, the inference rules applicable to these attributes are applied before the rules applicable to the node itself. The process of applying inference rules can be described with a pseudo code.</p><div class="code-block" data-lang="none">
                lookup-inference-rules(node) :
                let skipAttributed = false
                foreach a in attributesOf(node) do
                  if hasInferenceRuleFor(a) then
                    let rule = getInferenceRuleFor(a)
                    yield rule
                    if isSuperceding(rule) then
                      let skipAttributed = true
                    end if
                    if isOverriding(rule) then
                      break foreach loop
                    end if
                  end if
                end do
                if skipAttributed then
                  return
                end if
                /* proceed as usual */
                end
            </div><p id="-o3vd0q_360">An example of using an inference rule applicable to a node attribute shows how the presence condition can alter the type of a literal. Note that in this example the type of the annotated literal is affected by by both this inference rule and any other inference rule applicable to the node.</p><div class="code-block" data-lang="none">
                rule typeof_Literal {
                applicable for concept = PresenceConditionAnnotation as pca
                applicable always
                overrides false
                supercedes attributed false

                  do {
                    typeof(pca.parent) :&lt;=: pca.alternativeNode
                  }
                }
            </div></section><section class="chapter"><h3 id="conditionallyoverridingtypeinference" data-toc="conditionallyoverridingtypeinference">Conditionally overriding type inference</h3><p id="-o3vd0q_362">Keeping in mind that the condition under which the user might want to override the type inference via attributes depend on the configuration, we dont always want to override the default type.</p><div class="code-block" data-lang="none">
                rule typeof_Literal {
                applicable for concept = PresenceConditionAnnotation as pea
                applicable always
                  supercedes attributed {
                    isConditionSatisfied(pca);
                  }
                  do {
                    typeof(attributedNode) :==: pca.replacementType
                  }
                }
            </div></section></section><section class="chapter"><h2 id="checkingrules" data-toc="checkingrules">Checking rules</h2><p id="-o3vd0q_364">Checking, (or Non-typesystem) rules can inspect the model searching for known error patterns in code and report them to the user. This kind of pre-compilation code inspection is generally known as&nbsp;<b id="-o3vd0q_365">static code analysis</b>. Error patterns in typical tools for static code analysis can fall into several categories, such as correctness problems, multi-threaded correctness, I18N problems, vulnerability-increasing errors, styling issues, performance problems, etc. The found issues are reported to the user either on-demand through an interactive report:</p><figure id="-o3vd0q_366"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking1.png" class="lightbox"><img alt="Checking1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking1.png" title="Checking1.png" width="500" height="317"></a></figure><p id="-o3vd0q_367">or in a on-the-fly mode directly in the editor by colorful symbols and code underlines:</p><figure id="-o3vd0q_368"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking3.png" class="lightbox"><img alt="Checking3.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking3.png" title="Checking3.png" width="300" height="145"></a></figure><section class="chapter"><h3 id="severity" data-toc="severity">Severity</h3><p id="-o3vd0q_369">MPS distinguishes problems by severity:</p><ul class="list _bullet" id="-o3vd0q_370"><li class="list__item" id="-o3vd0q_371"><p>errors - displayed in red</p></li><li class="list__item" id="-o3vd0q_372"><p>warnings - displayed in yellow</p></li><li class="list__item" id="-o3vd0q_373"><p>infos - displayed in grayish</p></li></ul><p id="-o3vd0q_374">The&nbsp;<em id="-o3vd0q_375">jetbrains.mps.lang.typesystem</em> language offers corresponding statements that emit these problem categories together with their description and the node to highlight. The additional&nbsp;<em id="-o3vd0q_376">ensure</em>&nbsp;statement gives the user a more succinct syntax to report an error in case a condition is not met:</p><figure id="-o3vd0q_377"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking6.png" class="lightbox"><img alt="Checking6.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking6.png" title="Checking6.png" width="500" height="111"></a></figure><p id="-o3vd0q_378">Checking rules typically check for one or a few related issues in a given node or a small part of the model and report to the user, if a problem is discovered. The checking rules are attached to a concrete concept:</p><figure id="-o3vd0q_379"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking7.png" class="lightbox"><img alt="Checking7.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking7.png" title="Checking7.png" width="700" height="193"></a></figure><p id="-o3vd0q_380">The rule is called for every node that is an instance of that concept.</p><aside class="prompt" data-type="tip" data-title="" id="-o3vd0q_381"><p>Attaching checking rules to a condition specified as a pattern in the header of the checking rule has been deprecated and should no longer be used.</p></aside><p id="-o3vd0q_382">The applicability of a rule can be restricted to a specified pattern using the pattern language. This is handy for two main reasons:</p><ul class="list _bullet" id="-o3vd0q_383"><li class="list__item" id="-o3vd0q_384"><p>narrowing the applicability condition of the rule to only some occurrences of the concept</p></li><li class="list__item" id="-o3vd0q_385"><p>convenient naming of properties, children, grandchildren of the node</p></li></ul><p id="-o3vd0q_386">Both goals can be achieved by using the pattern language inside a rule's body, in particular, using the <em id="-o3vd0q_387">match</em> statement:</p><figure id="-o3vd0q_388"><img alt="checking_rule_pattern.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/checking_rule_pattern.png" title="checking_rule_pattern.png" width="700" height="201"></figure><p id="-o3vd0q_389">The pattern may contain variable parts (nodes, properties or references) that will match with any value, node or a reference in the model and the user can refer to them using the variable name.</p><p id="-o3vd0q_390">The <em id="-o3vd0q_391">overrides</em> option of a checking rule defines whether the current rule overrides some other checking rule that is applicable to a node.</p><figure id="-o3vd0q_392"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking7a.png" class="lightbox"><img alt="Checking7a.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking7a.png" title="Checking7a.png" width="700" height="188"></a></figure><p id="-o3vd0q_393">A checking rule defined for some concept is by default inherited by all of its subconcepts. Checking a node thus includes executing all rules defined for the concept of the node as well as rules defined for its superconcepts. In the rather rare situations when such inheritance of checking rules ahould be avoided, the <em id="-o3vd0q_394">overrides</em> option provides the means to do so. It enables you to explicitly specify the list of rules you want to override.</p><p id="-o3vd0q_395">Multiple overridden rules can be selected:</p><figure id="-o3vd0q_396"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking7b.png" class="lightbox"><img alt="Checking7b.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking7b.png" title="Checking7b.png" width="700" height="198"></a></figure></section><section class="chapter"><h3 id="patternlanguage" data-toc="patternlanguage">Pattern language</h3><p id="-o3vd0q_397">The pattern language gives the user reasonable flexibility to specify the desired pattern. Using&nbsp;<b id="-o3vd0q_398">Intentions</b> various parts of the pattern can be annotated with pattern-specific attributes and thus be given special meaning:</p><ul class="list _bullet" id="-o3vd0q_399"><li class="list__item" id="-o3vd0q_400"><p><b id="-o3vd0q_401">pattern variable</b> - can be used to turn a node or a reference of the pattern into a variable. It will match with any value on the given position and the user will be able to obtain the value by referring to the pattern variable</p></li><li class="list__item" id="-o3vd0q_402"><p><b id="-o3vd0q_403">pattern property variable</b> - the same as above, but applied to properties of nodes</p></li><li class="list__item" id="-o3vd0q_404"><p><b id="-o3vd0q_405">list pattern</b> - will match with a collection of nodes and allow the user to iterate over them</p></li><li class="list__item" id="-o3vd0q_406"><p><b id="-o3vd0q_407">or pattern</b> - will match with one of several provided sub-patterns</p></li><li class="list__item" id="-o3vd0q_408"><p><b id="-o3vd0q_409">wildcard</b> - will match with any (even non-existent) node on a given position. The user cannot refer to the matched value</p></li></ul><p id="-o3vd0q_410">A <b id="-o3vd0q_411">match</b> statement can be used to invoke node matching from <em id="-o3vd0q_412">BaseLanguage</em> code:</p><figure id="-o3vd0q_413"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Pattern3.png" class="lightbox"><img alt="Pattern3.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Pattern3.png" title="Pattern3.png" width="500" height="272"></a></figure></section><section class="chapter"><h3 id="quick-fixes" data-toc="quick-fixes">Quick-fixes</h3><p id="-o3vd0q_414">A&nbsp;<em id="-o3vd0q_415">quick-fix</em>&nbsp;provides a single model-transforming function, which will automatically eliminate the reported problem:</p><figure id="-o3vd0q_416"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking5.png" class="lightbox"><img alt="Checking5.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking5.png" title="Checking5.png" width="500" height="310"></a></figure><p id="-o3vd0q_417">A&nbsp;<em id="-o3vd0q_418">quick-fix</em>&nbsp;must provide a&nbsp;<b id="-o3vd0q_419">description</b>&nbsp;to represent it in the&nbsp;<b id="-o3vd0q_420">Intentions</b>&nbsp;context menu, unless it is only ever referred to from callers with&nbsp;<b id="-o3vd0q_421">apply immediately</b>&nbsp;set to&nbsp;<b id="-o3vd0q_422">true</b>. A&nbsp;<em id="-o3vd0q_423">quick-fix</em>&nbsp;may also declare&nbsp;<b id="-o3vd0q_424">fields</b>, to hold reused values, and it can accept&nbsp;<b id="-o3vd0q_425">arguments</b>&nbsp;from the caller.</p></section><section class="chapter"><h3 id="invokingquick-fixes" data-toc="invokingquick-fixes">Invoking quick-fixes</h3><p id="-o3vd0q_426">A <b id="-o3vd0q_427">quick-fix</b> may be associated with each reported problem through the <b id="-o3vd0q_428">Inspector</b> tool window using the <b id="-o3vd0q_429">intention to fix</b>:</p><figure id="-o3vd0q_430"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking4.png" class="lightbox"><img alt="Checking4.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking4.png" title="Checking4.png" width="500" height="273"></a></figure><p id="-o3vd0q_431">Normally the user invokes the&nbsp;<em id="-o3vd0q_432">quick-fix</em>&nbsp;through the&nbsp;<b id="-o3vd0q_433">Intentions</b>&nbsp;context menu, which is displayed after pressing the&nbsp;<kbd id="-o3vd0q_434" data-key="ShowIntentionActions">Alt+Enter</kbd> &nbsp;key shortcut. If the&nbsp;<b id="-o3vd0q_435">apply immediately</b> flag is set, however, MPS will run the associated&nbsp;<em id="-o3vd0q_436">quick-fix</em> as soon as the problem is discovered during on-the-fly analysis without waiting for the user trigger.</p><figure id="-o3vd0q_437"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Checking8.png" class="lightbox"><img alt="Checking8.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Checking8.png" title="Checking8.png" width="300" height="113"></a></figure><p id="-o3vd0q_438">The two other optional properties configured through the <b id="-o3vd0q_439">Inspector</b> are needed less frequently:</p><ul class="list _bullet" id="-o3vd0q_440"><li class="list__item" id="-o3vd0q_441"><p><b id="-o3vd0q_442">node feature to highlight</b> - specifies a node's property, child of reference to highlight as the source of the problem, instead of highlighting the whole node</p></li><li class="list__item" id="-o3vd0q_443"><p><b id="-o3vd0q_444">foreign message source</b> - when a user clicks (<em id="-o3vd0q_445">Control/Cmd + Alt + click</em>) on the reported error in the editor, she is taken to the&nbsp;<b id="-o3vd0q_446">Checking rule</b>'s <b id="-o3vd0q_447">error/warning/info/ensure</b> command that raised that error. With the&nbsp;<b id="-o3vd0q_448">foreign message source</b> property you can override this behavior and provide your own node that the user will be taken to upon clicking on the error.</p></li></ul></section></section><section class="chapter"><h2 id="typesystemadditionalmethods" data-toc="typesystemadditionalmethods">Additional methods</h2><p id="-o3vd0q_449">The <em id="-o3vd0q_450">additional methods</em> section at the bottom of <b id="-o3vd0q_451">inferrence rules</b>, <b id="-o3vd0q_452">checking rules</b> andd <b id="-o3vd0q_453">quick-fixes</b> allows the user to define utility methods that can be called from within the corresponding root node to avoid repetition. The additional methods typically perform calculations or perform tasks that are needed in multiple places of the definition. The additional methods must be <em id="-o3vd0q_454">private</em> to only be visible from within the containing node.</p></section><div class="last-modified">Last modified: 26 February 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="behavior.html" class="navigation-links__prev">Behavior</a><a href="using-typesystem.html" class="navigation-links__next">Using_typesystem</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/storage/help-app/v6/app.js"></script></body></html>