<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><link rel="canonical" href="https://www.jetbrains.com/help/mps/howto-integrating-into-the-mps-make-framework.html" data-react-helmet="true"/><meta charset="UTF-8"></meta><meta name="built-on" content="2024-08-08T15:14:22.620495211"><meta name="build-number" content="170"><title>HowTo -- Integrating into the MPS Make Framework | MPS Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"buildfacets","level":0,"title":"Build Facets","anchor":"#buildfacets"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/storage/help-app/v6/app.css" rel="stylesheet"><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="HowTo -- Integrating into the MPS Make Framework | MPS"><meta property="og:description" content=""><meta property="og:image" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><meta property="og:site_name" content="MPS Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://www.jetbrains.com/help/mps/howto-integrating-into-the-mps-make-framework.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@jetbrains_MPS"><meta name="twitter:title" content="HowTo -- Integrating into the MPS Make Framework | MPS"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@jetbrains_MPS"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://www.jetbrains.com/help/mps/howto-integrating-into-the-mps-make-framework.html#webpage",
    "url": "https://www.jetbrains.com/help/mps/howto-integrating-into-the-mps-make-framework.html",
    "name": "HowTo -- Integrating into the MPS Make Framework | MPS",
    "description": "",
    "image": "https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://www.jetbrains.com/help/mps/#website",
    "url": "https://www.jetbrains.com/help/mps/",
    "name": "MPS Help"
}</script><!-- End Schema.org --><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
</head><body data-id="howto-integrating-into-the-mps-make-framework" data-main-title="HowTo -- Integrating into the MPS Make Framework" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="mps-user-s-guide.topic|MPS User's Guide///mps-tutorials.topic|Tutorials"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MPS 2024.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="howto-integrating-into-the-mps-make-framework" id="howto-integrating-into-the-mps-make-framework.topic">HowTo -- Integrating into the MPS Make Framework</h1><section class="chapter"><h2 id="buildfacets" data-toc="buildfacets">Build Facets</h2><section class="chapter"><h3 id="overview" data-toc="overview">Overview</h3><p id="-ao7679_1">Like basically any build or make system, the MPS make executes a sequence of steps, or <b id="-ao7679_2">targets</b>, to build an artifact. A global ordering of the necessary make steps is derived from relative priorities specified for each build targets (target A has to run before B, and B has to run before C, so the global order is A, B, C).</p><p id="-ao7679_3">A complete build process may address several concerns, for example generating models into text, compiling these models, deploying them to the server, and generating .png files from graphviz source files. In MPS, such different build aspects are implemented with build <b id="-ao7679_4">facets</b>. A facet is a collection of targets that address a common concern.</p><figure id="-ao7679_5"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/facet10.png" class="lightbox"><img alt="facet10.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/facet10.png" title="facet10.png" width="300" height="146"></a></figure><aside class="prompt" data-type="tip" data-title="" id="-ao7679_6"><p id="-ao7679_7"><b id="-ao7679_8">Avoiding unnecessary file overwrites</b></p><p id="-ao7679_9">The make process does not overwrite generated files that hold identical content to the one just generated. You can rely on the fact that only the modified files get updated on disk.</p></aside><p id="-ao7679_10">The targets within a facet can exchange configuration parameters. For example, a target that is declared to run early in the overall make process may collect&nbsp;configuration parameters and pass them to the second facet, which then uses the parameters. The mechanism to achieve this intra-facet parameter exchange is&nbsp;called properties. In addition, targets can use queries to obtain information from the user during the make process.</p><figure id="-ao7679_11"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/facet11.png" class="lightbox"><img alt="facet11.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/facet11.png" title="facet11.png" width="300" height="202"></a></figure><p id="-ao7679_12">The overall make process is organized along the pipes and filters pattern. The targets act as filters, working on a stream of data being delivered to them. The data flowing among targets is called <b id="-ao7679_13">resources</b>. There are different kinds of resources, all represented as different Java interfaces and tuples:</p><figure id="-ao7679_14"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/facet12.png" class="lightbox"><img alt="facet12.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/facet12.png" title="facet12.png" width="300" height="70"></a></figure><ul class="list _bullet" id="-ao7679_15"><li class="list__item" id="-ao7679_16"><p><em id="-ao7679_17">MResource</em>&nbsp;contains MPS models created by users, those that are contained in the project's solutions and languages</p></li><li class="list__item" id="-ao7679_18"><p><em id="-ao7679_19">GResource</em> represents the results of the generation process, which includes the output models, that is the final state of the models after generation has completed. These are transient models, which may be inspected by using the&nbsp;<b id="-ao7679_20">Save Transient Models</b>&nbsp;build option</p></li><li class="list__item" id="-ao7679_21"><p><em id="-ao7679_22">TResource</em> represents&nbsp;the result of text-gen</p></li><li class="list__item" id="-ao7679_23"><p><em id="-ao7679_24">CResource</em>&nbsp;represents a collection of Java classes</p></li><li class="list__item" id="-ao7679_25"><p><em id="-ao7679_26">DResource</em>&nbsp;represents a collection of delta changes to models (<em id="-ao7679_27">IDelta</em>)</p></li><li class="list__item" id="-ao7679_28"><p><em id="-ao7679_29">TextGenOutcomeResource</em> represents&nbsp;the text files generated by textgen</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-ao7679_30"><p id="-ao7679_31">These resources interfaces have been deprecated:</p><ul class="list _bullet" id="-ao7679_32"><li class="list__item" id="-ao7679_33"><p><em id="-ao7679_34">IMResource</em> contains MPS models created by users, those that are contained in the project's solutions and languages</p></li><li class="list__item" id="-ao7679_35"><p><em id="-ao7679_36">IGResource</em> represents the results of the generation process, which includes the output models, that is the final state of the models after generation has completed. These are transient models, which may be inspected by using the&nbsp;<b id="-ao7679_37">Save Transient Models</b>&nbsp;build option</p></li><li class="list__item" id="-ao7679_38"><p><em id="-ao7679_39">ITResource</em> represents the text files generated by textgen towards the end of the make process</p></li><li class="list__item" id="-ao7679_40"><p><em id="-ao7679_41">FResource</em></p></li></ul></aside><p id="-ao7679_42">Build targets specify an interface. According to the pipes and filters pattern, the interface describes the kind of data that flows into and out of a make target. It is specified in terms of the resouce types mentioned above, as well as in terms of the kind of processing the target applies to these resources. The following four processing policies are defined:</p><ul class="list _bullet" id="-ao7679_43"><li class="list__item" id="-ao7679_44"><p>transform is the default. This policy consumes instances of the input resource type and produces instances of the output resource type (e.g. it may consume <code class="code" id="-ao7679_45">MResources</code> and produce <code class="code" id="-ao7679_46">TResources</code>.)</p></li><li class="list__item" id="-ao7679_47"><p>consume consumes the declared input, but produces no output. * produce consumes nothing, but produces output</p></li><li class="list__item" id="-ao7679_48"><p>pass through does not access any resources, neither produce nor consume.</p></li></ul><p id="-ao7679_49">Note that the make process is more coarse grained than model generation. In other words, there is one facet that runs all the model generators. If one needs to "interject" additional targets into the MPS generation process (as opposed to doing something before or after model generation), this requires refactoring the <code class="code" id="-ao7679_50">generate</code> facets. This is beyond the scope of this discussion.</p></section><section class="chapter"><h3 id="buildinganexamplefacet" data-toc="buildinganexamplefacet">Building an Example Facet</h3><p id="-ao7679_51">As part of the <b id="-ao7679_52">mbeddr.com</b> project to build a C base language for MPS, the actual C compiler has to be integrated into the MPS build process. More specifically, programs written in the C base language contain a way to generate a <code class="code" id="-ao7679_53">Makefile</code>. This <code class="code" id="-ao7679_54">Makefile</code> has to be executed once it and all the corresponding .c and .h files have been generated, i.e. at the very end of the MPS make process.</p><p id="-ao7679_55">To do this, we built a make facet with two targets. The first one inspects input models and collects the absolute paths of the directories that may contain a <code class="code" id="-ao7679_56">Makefile</code> after textgen. The second target then checks if there is actually a file called <code class="code" id="-ao7679_57">Makefile</code> in this directory and then runs make there. The two targets exchange the directories via properties, as discussed in the overview above.</p><aside class="prompt" data-type="tip" data-title="" id="-ao7679_58"><p id="-ao7679_59">The <em id="-ao7679_60">sampleFacet</em> sample project that comes bundled with MPS distributions provides a simple facet definition that you can take as a starting point for your adventure with make facets.</p></aside><section class="chapter"><h4 id="thefirsttarget:collectingdirectories" data-toc="thefirsttarget:collectingdirectories">The first target: Collecting Directories</h4><p id="-ao7679_61">Facets live in the <code class="code" id="-ao7679_62">plugins</code> aspect of a language definition. Make sure you include the {{jetbrains.mps.make.facets} language into the plugins model, so you can create instances of <code class="code" id="-ao7679_63">FacetDeclaration</code>. A facet is executed as part of the make process of a model if that model <code class="code" id="-ao7679_64">uses</code> the language that declares the facet.</p><p id="-ao7679_65">The facet is called <code class="code" id="-ao7679_66">runMake</code>. It depends on <code class="code" id="-ao7679_67">TextGen</code> and <code class="code" id="-ao7679_68">Generate</code>. The dependencies to those two facets has to be specified so we can then declare our targets' priorities relative to targets in those facets.</p><div class="code-block" data-lang="none">facet runMake extends &lt;none&gt;
  Required: TextGen, Generate
</div><p id="-ao7679_70">The first target is called <code class="code" id="-ao7679_71">collectPaths</code>. It is specified as {{transform IMResource -&gt; IMResource} in order to get in touch with the input models. The facet specifies, as priorities, <code class="code" id="-ao7679_72">after configure</code> and <code class="code" id="-ao7679_73">before generate</code>. The latter is obvious, since we want to get at the models before they are generated into text. The former priority essentially says that we want this target to run after the make process has been initialized (in other words: if you want to do something "at the beginning", use these two priorities.)</p><div class="code-block" data-lang="none">target collectPathes overrides &lt;none&gt; {
  resources policy: transform IMResource -&gt; IMResource
  Dependencies:
    after configure
    before generate
</div><p id="-ao7679_75">We then declare a property <code class="code" id="-ao7679_76">pathes</code> which we use to store information about the modules that contain make files, and the paths to the directories in which the generated code will reside.</p><div class="code-block" data-lang="none">Properies:
     list&lt;[string, string]&gt; pathes;
</div><p id="-ao7679_78">Let's now look at the implementation code of the target. Here is the basic structure. We first initialize the <code class="code" id="-ao7679_79">pathes</code> list. We then iterate of the input (which is a collection of resources) and do something with each input (explained below). We then use the <code class="code" id="-ao7679_80">output</code> statement to output the input data, in other words, we just pass through whatever came into out target. We use the <code class="code" id="-ao7679_81">success</code> statement to finish this target successfully (using <code class="code" id="-ao7679_82">success</code> at the end is optional, since this is the default). If something goes wrong, the <code class="code" id="-ao7679_83">failure</code> statement can be used to terminate the target unsuccessfully.</p><div class="code-block" data-lang="none">(input)-&gt;void {
  pathes = new linkedlist&lt;[string, string]&gt;;
  input.forEach({~inpt =&gt;
    (module, models) res = ((module, models)) inpt;
    // do stuff. See below.
  });
  output input;
  success;
}
</div><p id="-ao7679_85">The actual processing is straight forward Java programming against MPS data structures:</p><div class="code-block" data-lang="none">res.models.forEach({~model =&gt;
  string path = res.module.getFacet(GenerationTargetFacet.class).getOutputLocation() + "/" +
                model.getLongName().replaceAll("\\.", "/");
  string locationInfo = res.module.getModuleFqName() + "/" +
                        model.getLongName();
  pathes.add([path, locationInfo]);
});
</div><p id="-ao7679_87">We use the <code class="code" id="-ao7679_88">getOutputLocation</code> method of the <code class="code" id="-ao7679_89">GenerationTargetFacet</code> facet of the module to get the path to which the particular module generates its code (this can be configured by the user in the model properties). We then get the model's dotted name and replace the dots to slashes, since this is where the generated files of a model in that module will end up (inspect any example MPS project to see this). We then store the module's name and the model's name, separated by a slash, as a way of improving the logging messages in our second target (via the variable <code class="code" id="-ao7679_90">locationInfo}). We add the two strings to the {{pathes</code> collection. This <code class="code" id="-ao7679_91">pathes</code> property is queried by the second target in the facet.</p></section><section class="chapter"><h4 id="thesecondtarget:runningmake" data-toc="thesecondtarget:runningmake">The second Target: Running Make</h4><p id="-ao7679_92">This one uses the <code class="code" id="-ao7679_93">pass through</code> policy since it does not have to deal with resources. All the input it needs it can get from the properties of the <code class="code" id="-ao7679_94">collectPaths</code> target discussed above. This second target runs <code class="code" id="-ao7679_95">after collectPaths}, {{after textGen</code> and <code class="code" id="-ao7679_96">before reconcile</code>. It is obvious that is has to run after <code class="code" id="-ao7679_97">collectPaths}, since it uses the property data populated by it. It has to run after {{textGen}, otherwise the make files aren't there yet. And it has to run before {{reconcile}, because basically everything has to run before {{reconcile</code></p><div class="code-block" data-lang="none">target callMake overrides &lt;none&gt;
  resources policy: pass through
  Dependencies:
    after collectPathes
    after textGen
    before reconcile
</div><p id="-ao7679_99">let's now look at the implementation code. We start by grabbing all those entries from the <code class="code" id="-ao7679_100">collectPathes.pathes</code> property that actually contain a <code class="code" id="-ao7679_101">Makefile</code>. If none is found, we return with <code class="code" id="-ao7679_102">success</code>.</p><div class="code-block" data-lang="none">sequence&lt;[string, string]&gt; modelDirectoriesWithMakefile =
     collectPathes.pathes.
     where({~it =&gt; new File(it[0] + "/Makefile").exists();
  });
  if (modelDirectoriesWithMakefile.isEmpty) { success; }
</div><p id="-ao7679_104">We then use the progress indicator language to set up the progress bar with as many work units as we have directories with make files in them.</p><div class="code-block" data-lang="none">begin work "run make" covering ALL units of total work left,
     expecting modelDirectoriesWithMakefile.size units;
</div><p id="-ao7679_106">We then iterate over all the entries in the {{modelDirectoriesWithMakefile} collection. In the loop we advance the progress indicator and then use Java standard APIs to run the make file.</p><div class="code-block" data-lang="none">foreach dirInfoTuple in modelDirectoriesWithMakefile {
    try {
      advance 1 units of "run make"
         with comment "running make for " + dirInfoTuple[1];
      Process process = Runtime.getRuntime().
         exec("make", new string[0], new File(dirInfoTuple[0]));
      if (process.waitFor() &gt; 0) {
        error "make failed with exit code " + process.exitValue() + " for " +
              dirInfoTuple[1];
      } else {
        info "make finished successfully for " + dirInfoTuple[1];
      }
    } catch (Exception ex) {
      error ex.getMessage(), ex;
    }
  }
</div><p id="-ao7679_108">To wrap up the target, we use the <code class="code" id="-ao7679_109">finish</code> statement to clean up the progress bar.</p><div class="code-block" data-lang="none">finish "run make";
</div></section></section></section><div class="last-modified">Last modified: 11 February 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="common-language-patterns.html" class="navigation-links__prev">Common language patterns</a><a href="howto-adding-additional-tools-aka-views.html" class="navigation-links__next">HowTo -- Adding additional Tools (aka Views)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/storage/help-app/v6/app.js"></script></body></html>