<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><link rel="canonical" href="https://www.jetbrains.com/help/mps/migrations.html" data-react-helmet="true"/><meta charset="UTF-8"></meta><meta name="built-on" content="2024-08-08T15:14:23.324952165"><meta name="build-number" content="170"><title>Migrations | MPS Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"languageversion","level":0,"title":"Language version","anchor":"#languageversion"},{"id":"migrationassistant","level":0,"title":"Migration assistant","anchor":"#migrationassistant"},{"id":"baselinempsversion","level":0,"title":"Baseline MPS version","anchor":"#baselinempsversion"},{"id":"defininglanguagemigrations","level":0,"title":"Defining language migrations","anchor":"#defininglanguagemigrations"},{"id":"conceptreplacement","level":0,"title":"Concept replacement","anchor":"#conceptreplacement"},{"id":"definingprojectmigrations","level":0,"title":"Defining project migrations","anchor":"#definingprojectmigrations"},{"id":"multiplebranches","level":0,"title":"Multiple branches","anchor":"#multiplebranches"},{"id":"migrationanttask","level":0,"title":"Migration Ant Task","anchor":"#migrationanttask"},{"id":"examples","level":0,"title":"Examples","anchor":"#examples"},{"id":"changesmadebymigrationsinlocalhistoryview","level":0,"title":"Changes made by migrations in Local History view","anchor":"#changesmadebymigrationsinlocalhistoryview"},{"id":"migrationassistantinintellijidea","level":0,"title":"Migration assistant in IntelliJ IDEA","anchor":"#migrationassistantinintellijidea"},{"id":"discoveringdeprecatedcode","level":0,"title":"Discovering deprecated code","anchor":"#discoveringdeprecatedcode"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/storage/help-app/v6/app.css" rel="stylesheet"><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="Migrations | MPS"><meta property="og:description" content=""><meta property="og:image" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><meta property="og:site_name" content="MPS Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://www.jetbrains.com/help/mps/migrations.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@jetbrains_MPS"><meta name="twitter:title" content="Migrations | MPS"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@jetbrains_MPS"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://www.jetbrains.com/help/mps/migrations.html#webpage",
    "url": "https://www.jetbrains.com/help/mps/migrations.html",
    "name": "Migrations | MPS",
    "description": "",
    "image": "https://resources.jetbrains.com/storage/products/mps/img/meta/preview.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://www.jetbrains.com/help/mps/#website",
    "url": "https://www.jetbrains.com/help/mps/",
    "name": "MPS Help"
}</script><!-- End Schema.org --><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
</head><body data-id="migrations" data-main-title="Migrations" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="mps-user-s-guide.topic|MPS User's Guide///language-definition.topic|Language-definition"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>MPS 2024.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="migrations" id="migrations.topic">Migrations</h1><p id="d56ft6_1">After a language has been published and users have started using it, the language authors have to be careful with further changes to the language definition. In particular, removing concepts or adding and removing properties, children and references to concepts will introduce incompatibilities between the previous and the next language version. This impacts the users of the language if they update to the next language version, since they may discover that their model no longer matches the language definitions and get appropriate errors reported from their models.</p><p id="d56ft6_2">MPS&nbsp;<b id="d56ft6_3">tracks versions of languages</b> used in projects and provides automatic migrations to upgrade the usages of a language to the most recent versions. The language designers can create maintenance "migration" code to run automatically against the user code and thus change the user's code so that it complies with the changes made to the language definition. This is called&nbsp;<b id="d56ft6_4">language migration</b>.</p><p id="d56ft6_5">The full language migration story has several aspects:</p><ul class="list _bullet" id="d56ft6_6"><li class="list__item" id="d56ft6_7"><p>Language designers can write scripts for migrating the user code and bundle them with the language</p></li><li class="list__item" id="d56ft6_8"><p>MPS automatically tracks language versions used in the client code</p></li><li class="list__item" id="d56ft6_9"><p>MPS controls that the user's project is up-to-date with all language changes</p></li><li class="list__item" id="d56ft6_10"><p>MPS runs the necessary migrations, when necessary</p></li></ul><p id="d56ft6_11">There are two types of migrations available in MPS:</p><ul class="list _bullet" id="d56ft6_12"><li class="list__item" id="d56ft6_13"><p><b id="d56ft6_14">Language migrations</b> - migrations that upgrade the project to comply with the next version of the&nbsp;language&nbsp;definition. Each language migration is attached to a version of the language definition.</p></li><li class="list__item" id="d56ft6_15"><p><b id="d56ft6_16">Project migrations</b>-&nbsp;these are not triggered by language usages, but instead they themselves define&nbsp;the conditions, under which&nbsp;they should be run. These migrations are always applied to the whole project.</p></li></ul><section class="chapter"><h2 id="languageversion" data-toc="languageversion">Language version</h2><p id="d56ft6_17">Languages store a version number in their module definition (.mpl) file. This number increases when a new migration is created in a language's "migration" aspect</p><p id="d56ft6_18">Modules that use languages contain a version number associated with each used language reference&nbsp;in the module (.msd, .mpl) file. These represent the language version used by the module. The number changes when the corresponding migration is run against this module to migrate it to a later language version.</p><p id="d56ft6_19">The version number of a language can be viewed and modified manually in the&nbsp;<b id="d56ft6_20">Properties</b> dialog for a language:</p><figure id="d56ft6_21"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Migrationx1003.png" class="lightbox"><img alt="Migrationx1003.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migrationx1003.png" title="Migrationx1003.png" width="500" height="241"></a></figure><p id="d56ft6_22">Notice that there are two numbers available:</p><ul class="list _bullet" id="d56ft6_23"><li class="list__item" id="d56ft6_24"><p>Language version - updated each time the structure of the &nbsp;language changes</p></li><li class="list__item" id="d56ft6_25"><p>Module version - updated each time the references to the nodes in the module were migrated.&nbsp;If you perform a migration on a module with sources, e.g. moving nodes, you need a migration, which will be run on <b id="d56ft6_26">references</b> or on <b id="d56ft6_27">depending modules</b>. <em id="d56ft6_28">Module version</em>&nbsp;tracks that.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="d56ft6_29"><p>The migration subsystem also tracks the version of the MPS platform that was used to run each migration. This way it can raise a warning if a project migrated by a particular version of MPS is being open by an older version of MPS.</p></aside></section><section class="chapter"><h2 id="migrationassistant" data-toc="migrationassistant">Migration assistant</h2><p id="d56ft6_30">When MPS detects that the modules within the currently open project refer to versions of languages older than the ones present, a&nbsp;<b id="d56ft6_31">Migration assistant</b> is run. It prompts the user whether the migrations should be run in order to update the project to the most recent versions of the languages.</p><figure id="d56ft6_32"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1003.png" class="lightbox"><img alt="Migration1003.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1003.png" title="Migration1003.png" width="500" height="117"></a></figure><p id="d56ft6_33">A detailed list of the migrations that will be run is presented to the user:</p><figure id="d56ft6_34"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1.png" class="lightbox"><img alt="Migration1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1.png" title="Migration1.png" width="500" height="496"></a></figure><p id="d56ft6_35"><b id="d56ft6_36">Pre migration check</b> - when the migration is launched, MPS checks the validity of the project and its suitability for migration. This includes checking whether all needed migration scripts are available to cover the version gap of the languages in question, checking that all used libraries have already been migrated, detecting and reporting broken references in the project, checking whether the language is holistic. <br> Some of the problems block further migration execution, others allow the user to explicitly allow proceeding.</p><p id="d56ft6_38">If the user triggers the migration, the project is fully migrated. In case of problems preventing the migration, a list of problems together with the list of not migrated code is presented to the user.</p><p id="d56ft6_39"><b id="d56ft6_40">Pre-Update Check</b> - The <em id="d56ft6_41">Main Menu | Migration | Run Pre-Update Check</em> menu item triggers an action that is advised to run against your project before you update your MPS version. You run it in the old MPS instance to verify that there are no unmigrated left-overs that the new version of MPS may have issues with. Namely, it invokes all <em id="d56ft6_42">check()</em> methods of all migrations scripts of the languages used in the project. The action will attempt to fix all probable problems of these cases:</p><ul class="list _bullet" id="d56ft6_43"><li class="list__item" id="d56ft6_44"><p>New nodes written using old language versions were merged into a migrated branch from an unmigrated branch</p></li><li class="list__item" id="d56ft6_45"><p>Some nodes weren't fully migrated, typically because the migration gave up migrating them for being too complex and instead recommended a manual migration for these nodes, which then never happened.</p></li></ul><p id="d56ft6_46"><b id="d56ft6_47">Execute Re-Runnable Migrations</b> - The <em id="d56ft6_48">Main Menu | Migration | Migrations | Execute Re-Runnable Migrations</em> menu item triggers an action that will run all available re-runnable migrations. Since re-runnable migrations declare that they are safe to run on already migrated code, this action will only migrate code that needs to be migrated and it will not touch up-to-date code.</p></section><section class="chapter"><h2 id="baselinempsversion" data-toc="baselinempsversion">Baseline MPS version</h2><p id="d56ft6_49">When a new project is created, a âbaselineâ MPS version is saved for the project. Project migrations from MPS versions earlier than the projectâs baseline version wonât be applied. This gives authors the flexibility to equip project migrations with a specified desired âbaselineâ version. This can be specified by the Project migration's interface âgetBaselineVersion():intâ method. For any project, the user can still apply any project migrations by running them manually from the Migrations menu.</p><p id="d56ft6_50">When a baseline version is not detected in a project, then 2018.1 is considered as its baseline version. In such a case, the Migration popup informs the user with the following message:</p><figure id="d56ft6_51"><img alt="MigProjectBase1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/MigProjectBase1.png" title="MigProjectBase1.png" width="300" height="135"></figure></section><section class="chapter"><h2 id="defininglanguagemigrations" data-toc="defininglanguagemigrations">Defining language migrations</h2><p id="d56ft6_52">Migrations are defined as <b id="d56ft6_53">Migration Classes</b>&nbsp;in the <b id="d56ft6_54">migrations aspect</b>&nbsp;of your language definition. Migration Classes are nodes of the <em id="d56ft6_55">MigrationScript</em>&nbsp;concept defined in the <em id="d56ft6_56">jetbrains.mps.lang.migration</em>&nbsp;language.</p><figure id="d56ft6_57"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1001.png" class="lightbox"><img alt="Migration1001.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1001.png" title="Migration1001.png" width="500" height="280"></a></figure><section class="chapter"><h3 id="numberingoflanguagesandmigrations" data-toc="numberingoflanguagesandmigrations">Numbering of languages and migrations</h3><ul class="list _bullet" id="d56ft6_58"><li class="list__item" id="d56ft6_59"><p>The name of each migration script holds a number</p></li><li class="list__item" id="d56ft6_60"><p>Each migration script defines a <b id="d56ft6_61">from version</b>&nbsp;property</p></li></ul><p id="d56ft6_62">When a new migration script is created, the language version is increased by 1 and the <em id="d56ft6_63">fromVersion</em> field in the migration is set to <b id="d56ft6_64">old value of the language version</b>. We can now say that the created migration script performs the migration <b id="d56ft6_65">from an old version to a new one</b>.</p><section class="chapter"><h4 id="numberingoflanguagesandmigrationstipsandtricks" data-toc="numberingoflanguagesandmigrationstipsandtricks">Numbering of languages and migrations tips and tricks</h4><ul class="list _bullet" id="d56ft6_66"><li class="list__item" id="d56ft6_67"><p>No migrations can be "missed". If a language contains a migration from version X and from version Y, it should also contain a migration for each versions between&nbsp;X and Y. If a migration is not found for some version, this means that no user is able to migrate from version X. Generation of such languages will end up with an error.</p></li><li class="list__item" id="d56ft6_68"><p>It's not necessary to store all migrations for a language. If some language was "published" and it's necessary to remove some of the older migrations, they could be removed. The from-versions of migrations left should form a range A..B, where A is any older version and B = &lt;current version&gt; - 1</p></li><li class="list__item" id="d56ft6_69"><p>If a migration is created by mistake and wasn't published (meaning no user has run it on his project), it can be freely removed. After removing the migration, execute "Correct Language version" from the language's context menu - this action allows to synchronize the language's version with the last migration's version.&nbsp;<b id="d56ft6_70">BE VERY CAREFUL</b>&nbsp;when doing this.</p></li></ul><figure id="d56ft6_71"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1002.png" class="lightbox"><img alt="Migration1002.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migration1002.png" title="Migration1002.png" width="300" height="407"></a></figure></section></section><section class="chapter"><h3 id="structureofamigration" data-toc="structureofamigration">Structure of a migration</h3><figure id="d56ft6_72"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Migrationx1002.png" class="lightbox"><img alt="Migrationx1002.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migrationx1002.png" title="Migrationx1002.png" width="300" height="185"></a></figure><p id="d56ft6_73">There are several optional elements that migrations may provide:</p><ul class="list _bullet" id="d56ft6_74"><li class="list__item" id="d56ft6_75"><p><b id="d56ft6_76">execute after</b>&nbsp;- to put an ordering constraint among migration scripts</p></li><li class="list__item" id="d56ft6_77"><p><b id="d56ft6_78">produces annotation data</b>&nbsp;-&nbsp;specifies the&nbsp;<em id="d56ft6_79">ConceptDeclaration</em>&nbsp;that will be used to hold the migration data produced by this script and possibly consumed by a later migration script.</p></li><li class="list__item" id="d56ft6_80"><p><b id="d56ft6_81">requires annotation data</b>&nbsp;- specifies the <em id="d56ft6_82">ConceptDeclaration</em>&nbsp;that will be used to represent the migration data produced by an earlier migration script. It also gives the data a logical name to represent it within this migration script.</p></li><li class="list__item" id="d56ft6_83"><p><span class="text-line-through" id="d56ft6_84"><b id="d56ft6_85">produces data (deprecated)</b></span> - legacy variant of transferring migration data, uses external files instead of node annotations.</p></li><li class="list__item" id="d56ft6_86"><p><span class="text-line-through" id="d56ft6_87"><b id="d56ft6_88">requires data (deprecated)</b></span> - legacy variant of tranferring migration data.</p></li><li class="list__item" id="d56ft6_89"><p><b id="d56ft6_90">description</b>&nbsp;- a helpful textual description of the script</p></li><li class="list__item" id="d56ft6_91"><p><b id="d56ft6_92">execute method</b>&nbsp;- each migration defines an <em id="d56ft6_93">execute()</em>&nbsp;method, which performs the actual model conversion for user models. The method receives the user module as a parameter and may refer to the defined elements in the&nbsp;<b id="d56ft6_94">required annotation data</b>&nbsp;section.</p></li><li class="list__item" id="d56ft6_95"><p><b id="d56ft6_96">isRerunnable</b>&nbsp;- migrations that declare the they are re-runnable can be safely run repetitively against a project that may have already been migrated with this migration before.</p></li><li class="list__item" id="d56ft6_97"><p><b id="d56ft6_98">check method</b>&nbsp;- each migration may define a <em id="d56ft6_99">check()</em>&nbsp;method, which verifies that the migration has been fully performed on all nodes in the project. The method is run right after the migration's <em id="d56ft6_100">execute()</em> finishes and also as part of the manual <em id="d56ft6_101">Pre-Update Check</em> action (<em id="d56ft6_102">Main Menu | Migration | Run Pre-Update Check</em>). The <em id="d56ft6_103">check()</em> method returns a sequence of <em id="d56ft6_104">NotMigratedNode</em> instances that failed to be migrated.</p></li></ul><p id="d56ft6_105"><b id="d56ft6_106">Data production and consumption</b></p><p id="d56ft6_107">The ability to pass data among migration scripts is useful in <b id="d56ft6_108">partitioning the migration process</b>. One migration script may, for example, migrate nodes from an old concept to a new one, while a following migration script will migrate all references to the original nodes to point to the new nodes. For this to work, the first script has to store <b id="d56ft6_109">ids</b> of the old and new nodes and publish the mapping as its <em id="d56ft6_110">produced data</em>. The second migration script will consume the data as <em id="d56ft6_111">required data</em>. Each time a reference to an old node has to be updated, the data will be used to find an id of the new node. Technically, producing data is simply attaching a special attribute containing data to any node that is close enough to the place to which the data is related. If there is no specific place to put annotation because it is related to the whole model, the data node will be attached as a new root in the current model.</p><p id="d56ft6_112">Migration scripts producing nodes with data should declare the concept of such nodes and use the&nbsp; <b id="d56ft6_113"><em id="d56ft6_114">putData</em> <em id="d56ft6_115">()</em></b> &nbsp;construction to insert each of such annotations into the model:</p><figure id="d56ft6_116"><img alt="producedata.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/producedata.png" title="producedata.png" width="530" height="132"></figure><p id="d56ft6_117">Nodes containing data can be retrieved by some other migration script running on another module depending on the module for which the data was produced:</p><figure id="d56ft6_118"><img alt="requiredata.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/requiredata.png" title="requiredata.png" width="700" height="153"></figure></section><section class="chapter"><h3 id="orderingofmigrationscripts" data-toc="orderingofmigrationscripts">Ordering of migration scripts</h3><p id="d56ft6_119">The implicit dependencies between migration scripts expressed through the <b id="d56ft6_120">requires annotation data</b>&nbsp;and <b id="d56ft6_121">produces annotation data</b>&nbsp;sections will take care of proper ordering of migration scripts. When script is migrating some module, it can use data stored for this module and all its dependencies, so consuming script will start migrating the module only after having run all the required producers on all dependencies of the module. There is no need to express those dependencies explicitly.</p><p id="d56ft6_122">However, in cases when it is necessary to execute some script only after some other scripts has been executed against the same module (without taking care about dependencies), such ordering constraint can be expressed through the&nbsp;<b id="d56ft6_123">execute after</b> section. If, for example, some property was moved from one concept to its superconcept, which happens to be declared in another language, the migration can be expressed with two migration scripts. The first script, applicable to the subconcept, copies the property value from the old deprecated property to the new one. The second script is applicable to the superconcept, it initiates the new property for such instances of the superconcept, which are not instances of the subconcept, with some default value. And let's suppose that the second script does some other initialization which depends on value of the moved property. So, the second script should be executed only after the first one, and that&nbsp;on every module.</p></section><section class="chapter"><h3 id="languagesfordefiningmigrations" data-toc="languagesfordefiningmigrations">Languages for defining migrations</h3><p id="d56ft6_124">The&nbsp;<em id="d56ft6_125">jetbrains.mps.lang.migration</em>&nbsp;language defines all concepts specific to migration scripts. When defining your migrations, you can use&nbsp;<em id="d56ft6_126">BaseLanguage</em>&nbsp;together with the&nbsp;<em id="d56ft6_127">jetbrains.mps.lang.smodel</em>&nbsp;and <em id="d56ft6_128"></em> <em id="d56ft6_129">.query</em> languages to manipulate the models. The&nbsp;<em id="d56ft6_130">ofType&lt;model&gt;</em>&nbsp;construct may be of particular use to obtain models contained in the passed-in&nbsp; <em id="d56ft6_131">SModule:</em></p><div class="code-block" data-lang="none">sequence&lt;SModel&gt; models = m.getModels();&amp;nbsp;
                models.ofType&lt;model&gt;.selectMany({~model =&gt; model.nodes(BaseDocComment); }).forEach({~node =&gt;
                ... });
            </div><p id="d56ft6_133">A typical migration first excludes the migration aspect models from migration and then scans for nodes that need to be migrated. A new node is created and initialised with the values and children of the old node. The old node is then replaced with the new node. Setting the id of the new node to the value of the id of the old node will allow references to this node to be migrated without loosing their target:</p><div class="code-block" data-lang="none">void execute(SModule m) {
                sequence&lt;model&gt; models = ((sequence&lt;model&gt;) m.getModels()).where({~it =&gt;
                !it.isAspectModel(migration); });
                models.selectMany({~m =&gt; m.nodes(OldComponent); }).forEach({~oldNode =&gt;
                node&lt;NewComponent&gt; newNode = &lt;NEW component $( oldNode.name )$ {&gt;;
                *( oldNode.member )*
                ((SNode) newNode/).setId(((SNode) oldNode/).getNodeId());
                oldNode.replace with(newNode);
                });
                }
            </div><p id="d56ft6_135"><em id="d56ft6_136">Note: The example comes from the "migrations" sample project. Quotations and anti-quotations are used in the sample migration to ease instantiation of the new nodes and copying the properties as well as children of the old node to the new one. The id of the new node is set explicitly using the "SNode.setId()" method. The "semantic downcast" (aka "/") operator must be used to get an SNode instance for a node.</em></p><p id="d56ft6_137">Schematically:</p><ol class="list _decimal" id="d56ft6_138" type="1"><li class="list__item" id="d56ft6_139"><p>The transformation is applied to some node. As a result, we have a reference to old node (call in No), and a new node (Nn).</p></li><li class="list__item" id="d56ft6_140"><p>IDs of No's descendants are preserved automatically: if a was-descendant node is a descendant of the output node after the transformation, it already has the same id.</p></li><li class="list__item" id="d56ft6_141"><p id="d56ft6_142">ID of No: MPS determines whether No is a descendant of an output node.</p><ol class="list _decimal" id="d56ft6_143" type="1"><li class="list__item" id="d56ft6_144"><p>If yes, we already have the target for references that pointed to the No (this is for "wrap" cases - the node is "wrapped" in another node as a result of the transformation)</p></li><li class="list__item" id="d56ft6_145"><p>If no, the Nn gets the ID of No (that's for the case when we changed the concept of a node, but the old node is semantically equivalent to the new one)</p></li></ol></li><li class="list__item" id="d56ft6_146"><p>No is replaced with Nn in the containing model.</p></li></ol><aside class="prompt" data-type="tip" data-title="" id="d56ft6_147"><p id="d56ft6_148">It's sometimes much simpler to decompose a complex migration into a sequence of transform-migrations rather then writing the data-persisting logic and pass it and produced/required data.</p></aside></section></section><section class="chapter"><h2 id="conceptreplacement" data-toc="conceptreplacement">Concept replacement</h2><p id="d56ft6_149">If a language designer decides to remove a language concept and perhaps replace it with a new one, she should not remove the concept definition from the language immediately. Instead, the concept should be deprecated first and a migration script should be provided to migrate the user code away from the deprecated concept.</p><aside class="prompt" data-type="tip" data-title="" id="d56ft6_150"><p id="d56ft6_151">It is generally a good strategy to move the concepts that are being deprecated into a separate <b id="d56ft6_152">virtual folder</b>&nbsp;to keep them separate from the concepts that form the current way of using the language. Changing a virtual package of a concept has no impact on the using references in user models.</p></aside><p id="d56ft6_153">The deprecated concept can be completely removed (but does not need to) in the version following after the one, in which it was deprecated. The migration scripts that refer to the deprecated concept have then be removed, too.</p></section><section class="chapter"><h2 id="definingprojectmigrations" data-toc="definingprojectmigrations">Defining project migrations</h2><p id="d56ft6_154">Project migrations are not typically used by language developers, but rather by the MPS team to describe changes in the model file format, in the module dependencies system and other project-wide things.</p><p id="d56ft6_155">Project migration are run against the whole project, so it's up to the MPS developer to think about how his migration will work when a part of a project changes. E.g. the user can update her project from the VCS, and in this case it may be not enough to know, that the project was migrated once; updated modules may still have to be migrated.</p><p id="d56ft6_156">MPS does not guarantee the order, in which project migrations will be run, so you basically can't write mutually dependent project migrations.</p><p id="d56ft6_157">Nevertheless, users can write their own project migrations. There's no special language for project migrations, so they are basically written as <em id="d56ft6_158">Java/BaseLanguage</em> classes and are contributed through plugin.xml. Further we'll suppose that you already have an MPS plugin and write the project migration in it.</p><section class="chapter"><h3 id="addinganewprojectmigrationv1" data-toc="addinganewprojectmigrationv1">Adding a new project migration - variant 1</h3><p id="d56ft6_159">This is a newer and a more straighforward of the two possible approaches.</p><ul class="list _bullet" id="d56ft6_160"><li class="list__item" id="d56ft6_161"><p>Create a plugin solution, enable "Contributes extensions to MPS" in its properties on the "Java" tab. Add a "plugin" model to it, import the <em id="d56ft6_162">jetbrains.mps.lang.standalone</em> language to the model.</p></li><li class="list__item" id="d56ft6_163"><p>Create a <em id="d56ft6_164">StandalonePluginDescriptor</em> in the model.</p></li><li class="list__item" id="d56ft6_165"><p>Create a class for the migration implementing the <em id="d56ft6_166">ProjectMigration</em> interface. For most cases, it's convenient to inherit from the <em id="d56ft6_167">BaseProjectMigration</em> class.</p></li><li class="list__item" id="d56ft6_168"><p>Create an <em id="d56ft6_169">ApplicationPlugin</em> that will contribute the new migrations. The <em id="d56ft6_170">init()</em> method should register the migrations using the <em id="d56ft6_171">ProjectMigrationsRegistry.getInstance().addProjectMigration()</em> method. The <em id="d56ft6_172">dispose()</em> method should unregister the migrations using the <em id="d56ft6_173">ProjectMigrationsRegistry.getInstance().removeProjectMigration()</em> method.</p></li></ul></section><section class="chapter"><h3 id="addinganewprojectmigrationv2" data-toc="addinganewprojectmigrationv2">Adding a new project migration - variant 2</h3><ul class="list _bullet" id="d56ft6_174"><li class="list__item" id="d56ft6_175"><p>Create a class for the migration implementing the <em id="d56ft6_176">ProjectMigration</em> interface. For most cases, it's convenient to inherit from the <em id="d56ft6_177">BaseProjectMigration</em> class.</p></li><li class="list__item" id="d56ft6_178"><p>Create an <em id="d56ft6_179">ApplicationComponent</em> that will contribute the new migrations. Do not forget to register it in <em id="d56ft6_180">plugin.xml</em></p></li><li class="list__item" id="d56ft6_181"><p>Contribute all your project migrations from created <em id="d56ft6_182">ApplicationComponent</em> using the&nbsp;<em id="d56ft6_183">ProjectMigrationsRegistry.addProjectMigration()</em> method</p></li></ul></section><section class="chapter"><h3 id="savingdatafromprojectmigrations." data-toc="savingdatafromprojectmigrations.">Saving data from project migrations.</h3><p id="d56ft6_184">Project migrations can use the&nbsp;<em id="d56ft6_185">MigrationProperties</em> project component&nbsp;to persist their data. The persisted data is stored in the .mps folder of the project and so it is shared between project's developers through VCS.</p></section></section><section class="chapter"><h2 id="multiplebranches" data-toc="multiplebranches">Multiple branches</h2><p id="d56ft6_186">Migrating projects that use multiple branches has a few additional challenges. For more information, refer to <a href="using-migrations-with-branching.html" id="d56ft6_187">Using Migration with branching</a>.</p></section><section class="chapter"><h2 id="migrationanttask" data-toc="migrationanttask">Migration Ant Task</h2><p id="d56ft6_188">There's an ant task to run all migrations in a project from an ant script. This task can be used for automatic testing of migrations and for checking whether a project has been migrated.</p><p id="d56ft6_189">This task requires the MPS home path to be set by</p><ol class="list _decimal" id="d56ft6_190" type="1"><li class="list__item" id="d56ft6_191"><p>defining mpshome task attribute <b id="d56ft6_192">or</b></p></li><li class="list__item" id="d56ft6_193"><p>defining <em id="d56ft6_194">mps_home</em> environment property&nbsp; <b id="d56ft6_195">or</b></p></li><li class="list__item" id="d56ft6_196"><p>defining <em id="d56ft6_197">mps.home</em>&nbsp;environment property - this is the preferred way</p></li></ol><p id="d56ft6_198">Home path is the path to the folder that contains the build.txt file. E.g. under Mac OS this will end with "/Contents/"</p><p id="d56ft6_199">Repository contents may be specified using the &lt;repository&gt; tag:</p><figure id="d56ft6_200"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/Repositoryx1.png" class="lightbox"><img alt="Repositoryx1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Repositoryx1.png" title="Repositoryx1.png" width="600" height="353"></a></figure><p id="d56ft6_201">If a plugin is needed for a project to migrate, this can be specified in the &lt;migrate&gt; ant task. The corresponding plugin will be enabled, together with its dependencies.</p><figure id="d56ft6_202"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/MigratePlugins.png" class="lightbox"><img alt="MigratePlugins.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/MigratePlugins.png" title="MigratePlugins.png" width="1710" height="256"></a></figure><p id="d56ft6_203">The task supports multiple project specifications (you can migrate several projects at once). Either use nested &lt;project path="â/&gt; elements or a regular Antâs &lt;dirset&gt; to enumerate project locations for the task.</p><p id="d56ft6_204">Three attributes to the <em id="d56ft6_205">migrate</em> task are available:</p><ul class="list _bullet" id="d56ft6_206"><li class="list__item" id="d56ft6_207"><p><b id="d56ft6_208">makeDistribModules</b> - indicates, whether the MPS distribution modules should be compiled and reloaded before running the migration itself.</p></li><li class="list__item" id="d56ft6_209"><p><b id="d56ft6_210">autoPluginDiscovery</b> - indicates, whether the task should automatically discover and load installed plugins. Set it to <em id="d56ft6_211">false</em> when plugins are specified explicitly as part of the task.</p></li><li class="list__item" id="d56ft6_212"><p><b id="d56ft6_213">haltOnDependencyError</b> - when the migration process detects that some of the dependencies have not been migrated, it stops the migration by default. This attribute allows the ant task to continue migration in such cases. Stopping the migration process as soon as a non-migrated dependency is discovered is the default behavior.</p></li></ul><figure id="d56ft6_214"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/migrationtaskattrs.png" class="lightbox"><img alt="migrationtaskattrs.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/migrationtaskattrs.png" title="migrationtaskattrs.png" width="1458" height="310"></a></figure></section><section class="chapter"><h2 id="examples" data-toc="examples">Examples</h2><p id="d56ft6_215">For examples on how to define migrations you can check out the <b id="d56ft6_216">migrations sample project</b>&nbsp;that comes bundled with MPS. You will see migration scripts&nbsp;to migrate two simple mutually interconnected languages. One of them uses data to pass information about migrated nodes between two migration scripts, while the other relies of node id manipulation.</p></section><section class="chapter"><h2 id="changesmadebymigrationsinlocalhistoryview" data-toc="changesmadebymigrationsinlocalhistoryview">Changes made by migrations in Local History view</h2><p id="d56ft6_217">Migrations cooperate with the&nbsp;<b id="d56ft6_218">Local History</b>&nbsp;functionality.</p><figure id="d56ft6_219"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/lh1.png" class="lightbox"><img alt="lh1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/lh1.png" title="lh1.png" width="300" height="355"></a></figure><p id="d56ft6_220">After running migrations, it's possible to review all the changes made to the project by each of the migration. Open the Local History view for the project's folder, a module or a model, select any two changes and press&nbsp;<em id="d56ft6_221">Ctrl + D</em>&nbsp;to see the difference.</p><figure id="d56ft6_222"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/lh2.png" class="lightbox"><img alt="lh2.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/lh2.png" title="lh2.png" width="300" height="380"></a></figure><figure id="d56ft6_223"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/lh3.png" class="lightbox"><img alt="lh3.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/lh3.png" title="lh3.png" width="500" height="372"></a></figure><p id="d56ft6_224">It's also possible to revert a change or a group of changes from the Local History view as well as from the Diff dialogs.</p></section><section class="chapter"><h2 id="migrationassistantinintellijidea" data-toc="migrationassistantinintellijidea">Migration assistant in IntelliJ IDEA</h2><p id="d56ft6_225">The&nbsp;IntelliJ IDEA plugin can also run language migrations. Just like in MPS itself, the <b id="d56ft6_226">Migration assistant</b> will update models in IDEA projects to match the currently installed versions of used languages.</p><figure id="d56ft6_227"><a href="https://resources.jetbrains.com/help/img/idea/2024.1/IDEA-Migration1.png" class="lightbox"><img alt="IDEA-Migration1.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/IDEA-Migration1.png" title="IDEA-Migration1.png" width="500" height="313"></a></figure></section><section class="chapter"><h2 id="discoveringdeprecatedcode" data-toc="discoveringdeprecatedcode">Discovering deprecated code</h2><p id="d56ft6_228">Deprecation is a recommended mechanism to indicate to the users of a language that an element will be removed in one of the next versions of your language. MPS provides several handy finders to help users eliminate deprecated code.&nbsp;<b id="d56ft6_229">Find Usages of Deprecated</b>&nbsp;can find all usages of deprecated elements. The report of the found usages groups the entries by the expected version of the code removal. This makes it easier to recognise their severity and prioritise their elimination.</p><figure id="d56ft6_230"><img alt="Migx.png" src="https://resources.jetbrains.com/help/img/idea/2024.1/Migx.png" title="Migx.png" width="900" height="727"></figure></section><div class="last-modified">Last modified: 29 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="textgen.html" class="navigation-links__prev">TextGen</a><a href="using-migrations-with-branching.html" class="navigation-links__next">Using Migrations with branching</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/storage/help-app/v6/app.js"></script></body></html>